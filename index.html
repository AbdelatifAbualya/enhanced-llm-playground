<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>LLM Playground (COT vs COD)</title>
  <!-- Google Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500&family=Roboto+Mono:wght@400;500&display=swap" rel="stylesheet">
  <style>
    /* --------------------------------
       Global Styles
    -------------------------------- */
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      padding: 0;
      font-family: 'Roboto', sans-serif;
      background: linear-gradient(145deg, #0F0F0F 0%, #1F1F1F 100%);
      color: #e0e0e0;
      overflow: hidden;
    }
    .app-container {
      display: flex;
      height: 100vh;
      overflow: hidden;
    }
    /* --------------------------------
       Sidebar Styles
    -------------------------------- */
    .sidebar {
      width: 250px;
      background-color: rgba(30, 30, 30, 0.95);
      padding: 1rem;
      border-right: 1px solid #333;
      overflow-y: auto;
      box-shadow: 2px 0 5px rgba(0,0,0,0.4);
    }
    .sidebar h2 {
      margin-top: 0;
      margin-bottom: 1rem;
      font-size: 1.2rem;
      color: #fff;
    }
    .sidebar ul {
      list-style: none;
      padding: 0;
      margin: 0;
    }
    .sidebar li {
      padding: 0.5rem;
      margin-bottom: 0.5rem;
      border-radius: 8px;
      cursor: pointer;
      transition: background-color 0.3s ease;
    }
    .sidebar li:hover {
      background-color: #333;
    }
    .sidebar li.active {
      background-color: #444;
    }
    .sidebar button {
      width: 100%;
      margin-top: 0.5rem;
      padding: 0.5rem;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-size: 0.9rem;
      transition: background-color 0.3s ease;
      box-shadow: 0 1px 3px rgba(0,0,0,0.4);
    }
    /* Normal button style */
    .sidebar button:not(#downloadTxtBtn):not(#downloadPdfBtn) {
      background-color: #3a3a3a;
      color: #fff;
    }
    .sidebar button:not(#downloadTxtBtn):not(#downloadPdfBtn):hover {
      background-color: #4a4a4a;
    }
    /* Visual Studio–like style for PDF/TXT download buttons */
    #downloadTxtBtn,
    #downloadPdfBtn {
      background-color: #1e1e1e;
      color: #d4d4d4;
      border: 1px solid #3c3c3c;
    }
    #downloadTxtBtn:hover,
    #downloadPdfBtn:hover {
      background-color: #2d2d2d;
    }
    /* --------------------------------
       Chat Container Styles
    -------------------------------- */
    .chat-container {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      background: linear-gradient(145deg, #181818 0%, #202020 100%);
      position: relative;
    }
    .chat-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1rem;
      background-color: rgba(30,30,30,0.95);
      border-bottom: 1px solid #333;
      box-shadow: 0 2px 4px rgba(0,0,0,0.5);
      z-index: 1;
    }
    .chat-header h1#pageTitle {
      margin: 0;
      font-size: 1.5rem;
      color: #fff;
      user-select: none;
    }
    .settings-btn {
      background: none;
      border: none;
      color: #fff;
      font-size: 1.2rem;
      cursor: pointer;
      margin-left: 0.5rem;
      transition: color 0.3s ease;
    }
    .settings-btn:hover {
      color: #ccc;
    }
    .chat-messages {
      flex: 1;
      padding: 1rem;
      overflow-y: auto;
      scroll-behavior: smooth;
    }
    .chat-input {
      display: flex;
      border-top: 1px solid #333;
      background-color: rgba(30,30,30,0.95);
      padding: 1rem;
      box-shadow: 0 -2px 4px rgba(0,0,0,0.3);
    }
     .chat-input textarea {
      flex: 1;
      resize: vertical; /* Allow vertical resizing */
      border: none;
      background-color: #2e2e2e;
      color: #fff;
      padding: 0.5rem;
      border-radius: 8px;
      font-size: 1rem;
      outline: none;
      box-shadow: inset 0 1px 3px rgba(0,0,0,0.4);
      min-height: 100px; /* Set minimum height */
      max-height: 300px; /* Set maximum height */
    }
    .chat-input button {
      margin-left: 1rem;
      padding: 0.5rem 1rem;
      background-color: #3a3a3a;
      border: none;
      color: #fff;
      border-radius: 8px;
      cursor: pointer;
      font-size: 1rem;
      transition: background-color 0.3s ease;
      box-shadow: 0 1px 3px rgba(0,0,0,0.4);
    }
    .chat-input button:hover {
      background-color: #4a4a4a;
    }
    /* --------------------------------
       Message Styles
    -------------------------------- */
    .message {
      clear: both;
      margin-bottom: 1.5rem;
      max-width: 80%;
      padding: 0.75rem 1rem;
      border-radius: 12px;
      line-height: 1.4;
      word-wrap: break-word;
      background-color: #2e2e2e;
      border: 1px solid #444;
      box-shadow: 0 1px 3px rgba(0,0,0,0.3);
      position: relative;
      overflow: hidden;
    }
    .message.user {
      float: right;
      background-color: #3a3a3a;
      margin-left: 20%;
    }
    .message.bot {
      float: left;
      background-color: #2e2e2e;
      margin-right: 20%;
    }
    .message.bot.placeholder {
      font-style: italic;
      color: #888;
    }
    /* IMPROVED: Thinking steps and final answer styling */
    .message-container {
      width: 100%;
      overflow: hidden;
    }
    .thinking-steps {
      background-color: #252525;
      border: 1px solid #333;
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 15px;
      font-family: 'Roboto Mono', monospace;
      font-size: 0.85rem;
      color: #aaa;
      white-space: pre-wrap;
      overflow-x: auto;
    }
    .thinking-label {
      font-size: 0.7rem;
      font-family: 'Roboto', sans-serif;
      color: #777;
      margin-bottom: 8px;
      text-transform: uppercase;
      letter-spacing: 1px;
      font-weight: bold;
      border-bottom: 1px dotted #555;
      padding-bottom: 5px;
    }
    .final-answer {
      background-color: #2d3748;
      border: 1px solid #4a5568;
      border-radius: 8px;
      padding: 15px;
      margin-top: 5px;
      color: #edf2f7;
    }
    .final-answer-label {
      font-size: 0.7rem;
      color: #90cdf4;
      margin-bottom: 8px;
      text-transform: uppercase;
      letter-spacing: 1px;
      font-weight: bold;
      border-bottom: 1px dotted #5a7299;
      padding-bottom: 5px;
    }
    .step {
      border-left: 2px solid #3a4a5c;
      padding-left: 10px;
      margin-bottom: 8px;
    }
    .word-count-badge {
      position: absolute;
      top: 10px;
      right: 10px;
      background-color: rgba(30, 30, 30, 0.9);
      color: #ddd;
      font-size: 0.7rem;
      padding: 3px 8px;
      border-radius: 12px;
      border: 1px solid #555;
      box-shadow: 0 1px 3px rgba(0,0,0,0.3);
      white-space: nowrap;
      z-index: 5;
    }
    /* --------------------------------
       Code Block Styles
    -------------------------------- */
    pre {
      background-color: #1f1f1f;
      padding: 0.75rem;
      border-radius: 8px;
      overflow-x: auto;
      margin: 0.5rem 0;
      position: relative;
    }
    code {
      font-family: Consolas, monospace;
      color: #dcdcdc;
    }
    .code-block-container {
      position: relative;
      margin: 0.5rem 0;
      background-color: #1f1f1f;
      border-radius: 8px;
      box-shadow: inset 0 1px 3px rgba(0,0,0,0.3);
      padding: 0.75rem;
    }
    .copy-btn {
      position: absolute;
      top: 8px;
      right: 8px;
      background-color: #333;
      border: none;
      color: #fff;
      border-radius: 4px;
      padding: 4px 8px;
      font-size: 0.8rem;
      cursor: pointer;
      transition: background-color 0.2s ease;
    }
    .copy-btn:hover {
      background-color: #444;
    }
    /* --------------------------------
       Modal Styles - IMPROVED
    -------------------------------- */
    .modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      overflow-y: auto; /* Changed from auto to allow scrolling */
      background-color: rgba(0, 0, 0, 0.7);
      backdrop-filter: blur(3px);
    }
    .modal-content {
      background-color: #1e1e1e;
      margin: 5% auto;
      padding: 20px;
      border: 1px solid #333;
      width: 600px; /* Wider to accommodate settings */
      max-width: 90%; /* Ensure it works on mobile */
      border-radius: 10px;
      color: #fff;
      box-shadow: 0 4px 10px rgba(0,0,0,0.5);
      position: relative;
      max-height: 85vh; /* Limit height and enable scrolling */
      overflow-y: auto;
    }
    .modal-content label {
      display: block;
      margin-bottom: 5px;
      font-size: 0.9rem;
    }
    .modal-content input, .modal-content select {
      width: 100%;
      padding: 0.4rem;
      margin-bottom: 1rem;
      border: 1px solid #333;
      border-radius: 5px;
      background-color: #2e2e2e;
      color: #fff;
      font-size: 0.9rem;
      outline: none;
      box-shadow: inset 0 1px 3px rgba(0,0,0,0.4);
    }
    .modal-content select {
      appearance: none;
      background-image: url("data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23FFFFFF%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E");
      background-repeat: no-repeat;
      background-position: right 0.7em top 50%;
      background-size: 0.65em auto;
      padding-right: 20px;
    }
    .modal-content button {
      padding: 0.5rem 1rem;
      background-color: #3a3a3a;
      border: none;
      color: #fff;
      border-radius: 5px;
      cursor: pointer;
      font-size: 1rem;
      margin-right: 0.5rem;
      transition: background-color 0.3s ease;
      box-shadow: 0 1px 3px rgba(0,0,0,0.4);
    }
    .modal-content button:hover {
      background-color: #4a4a4a;
    }
    .settings-tabs {
      display: flex;
      gap: 5px;
      margin-bottom: 15px;
    }
    .tab-btn {
      flex: 1;
      background-color: #2a2a2a;
      border: 1px solid #444;
      color: #aaa;
      padding: 8px 0;
      border-radius: 5px 5px 0 0;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    .tab-btn.active {
      background-color: #3a3a3a;
      color: #fff;
      border-bottom: 2px solid #4a8cff;
    }
    .tab-content {
      display: none;
      padding: 15px;
      background-color: #2a2a2a;
      border-radius: 0 0 5px 5px;
      margin-bottom: 20px;
    }
    .tab-content.active {
      display: block;
    }
    .checkbox-container {
      display: flex;
      align-items: center;
      margin-bottom: 10px;
    }
    .checkbox-container input[type="checkbox"] {
      width: auto;
      margin-right: 10px;
      margin-bottom: 0;
    }
    .tooltip {
      position: relative;
      display: inline-block;
      margin-left: 5px;
      cursor: help;
    }
    .tooltip .tooltiptext {
      visibility: hidden;
      width: 300px;
      background-color: #2e2e2e;
      color: #fff;
      text-align: left;
      border-radius: 6px;
      padding: 8px;
      position: absolute;
      z-index: 1;
      top: -5px;
      left: 105%;
      opacity: 0;
      transition: opacity 0.3s;
      box-shadow: 0 2px 5px rgba(0,0,0,0.3);
      font-size: 0.8rem;
      line-height: 1.4;
    }
    .tooltip:hover .tooltiptext {
      visibility: visible;
      opacity: 1;
    }
    
    /* --------------------------------
       Reasoning Method UI Improvements
    -------------------------------- */
    .feature-section {
      border: 1px solid #444;
      border-radius: 8px;
      padding: 12px;
      margin-bottom: 16px;
      background-color: #2a2a2a;
    }
    
    .feature-header {
      display: flex;
      align-items: center;
      margin-bottom: 10px;
    }
    
    .feature-header input[type="checkbox"] {
      margin-right: 8px;
    }
    
    .feature-header label {
      font-weight: 500;
      font-size: 1rem;
    }
    
    .feature-options {
      margin-left: 24px;
      padding-top: 8px;
      border-top: 1px solid #444;
    }
    
    .option-label {
      margin-bottom: 8px;
      color: #bbb;
      font-size: 0.9rem;
    }
    
    .radio-options {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-bottom: 10px;
    }
    
    .radio-option {
      display: flex;
      align-items: center;
    }
    
    .radio-option input[type="radio"] {
      margin-right: 8px;
      width: auto;
      cursor: pointer;
    }
    
    .radio-option label {
      cursor: pointer;
      margin-bottom: 0;
    }
    
    /* Make radio buttons more visible and clickable */
    input[type="radio"] {
      -webkit-appearance: none;
      -moz-appearance: none;
      appearance: none;
      border-radius: 50%;
      width: 16px;
      height: 16px;
      border: 2px solid #555;
      outline: none;
      margin-right: 8px;
      position: relative;
      cursor: pointer;
    }
    
    input[type="radio"]:checked {
      border-color: #4a8cff;
    }
    
    input[type="radio"]:checked:before {
      content: '';
      position: absolute;
      top: 3px;
      left: 3px;
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: #4a8cff;
    }
    
    /* Make checkboxes more visible and clickable */
    input[type="checkbox"] {
      -webkit-appearance: none;
      -moz-appearance: none;
      appearance: none;
      width: 16px;
      height: 16px;
      border: 2px solid #555;
      border-radius: 3px;
      outline: none;
      cursor: pointer;
      position: relative;
    }
    
    input[type="checkbox"]:checked {
      border-color: #4a8cff;
      background-color: #4a8cff;
    }
    
    input[type="checkbox"]:checked:before {
      content: '✓';
      position: absolute;
      color: white;
      font-size: 12px;
      top: -1px;
      left: 2px;
    }
    
    .tooltip {
      margin-left: 6px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 16px;
      height: 16px;
      background-color: #555;
      border-radius: 50%;
      font-size: 12px;
      cursor: help;
    }

    /* Status notification */
    .status-notification {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background-color: #2a2a2a;
      color: white;
      padding: 10px 15px;
      border-radius: 4px;
      box-shadow: 0 3px 6px rgba(0,0,0,0.3);
      z-index: 1001;
      display: none;
      opacity: 0;
      transition: opacity 0.3s ease;
    }
    
    .status-notification.show {
      display: block;
      opacity: 1;
    }
    
    /* Better modal close button */
    .close-modal {
      position: absolute;
      top: 15px;
      right: 15px;
      background: none;
      border: none;
      color: #aaa;
      font-size: 20px;
      cursor: pointer;
      padding: 0;
      margin: 0;
      transition: color 0.2s ease;
    }
    
    .close-modal:hover {
      color: #eee;
    }
    
    /* Current model display */
    .current-model-display {
      display: inline-block;
      padding: 4px 8px;
      border-radius: 4px;
      background-color: #253245;
      color: #fff;
      font-size: 0.9rem;
      margin-left: 10px;
    }
    
    .reasoning-badge {
      display: inline-block;
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 0.7rem;
      margin-left: 5px;
      background-color: #444;
    }
    
    /* Two column layout for some settings */
    .settings-row {
      display: flex;
      gap: 20px;
      margin-bottom: 15px;
    }
    
    .settings-column {
      flex: 1;
    }
    
    /* Prompt editing styles */
    .prompt-editor {
      margin-top: 15px;
    }
    
    .prompt-editor textarea {
      width: 100%;
      min-height: 150px;
      background-color: #252525;
      color: #ddd;
      border: 1px solid #444;
      border-radius: 5px;
      padding: 10px;
      font-family: monospace;
      font-size: 0.9rem;
      line-height: 1.4;
      resize: vertical;
    }
    
    .prompt-reset {
      margin-top: 5px;
      font-size: 0.8rem;
      color: #aaa;
      cursor: pointer;
      text-decoration: underline;
    }
    
    .prompt-reset:hover {
      color: #4a8cff;
    }

    /* Enhanced styles for Chain of Draft */
    .cod-thinking {
      background-color: #1e293b !important;
      border-color: #3d4e63 !important;
    }

    .cod-step {
      display: flex;
      align-items: flex-start;
      padding: 6px 8px;
      margin-bottom: 10px !important;
      border-left: none !important;
      background-color: #2c3b4f;
      border-radius: 6px;
      box-shadow: 0 1px 2px rgba(0,0,0,0.2);
    }

    .step-number {
      display: flex;
      align-items: center;
      justify-content: center;
      min-width: 24px;
      height: 24px;
      background-color: #3d4f69;
      border-radius: 12px;
      margin-right: 10px;
      color: #a3c5e9;
      font-size: 0.75rem;
      font-weight: bold;
    }

    .step-content {
      flex: 1;
      padding-right: 8px;
      font-family: 'Roboto Mono', monospace;
      color: #c5d5e8;
    }

    /* Enhanced token display */
    .token-savings {
      font-size: 0.7rem;
      color: #4ade80;
      margin-left: 5px;
    }

    /* COD Word Limit options */
    .cod-options {
      margin-top: 15px;
      display: none;
    }

    .cod-word-limit-options {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-bottom: 15px;
    }

    .cod-word-limit-option {
      display: flex;
      align-items: center;
      padding: 8px 12px;
      margin-bottom: 8px;
      background-color: #2a2a2a;
      border-radius: 6px;
      cursor: pointer;
      transition: background-color 0.2s ease;
    }

    .cod-word-limit-option:hover {
      background-color: #333;
    }

    .cod-word-limit-option.selected {
      background-color: #3a4a5c;
      border-left: 3px solid #4a8cff;
    }

    .cod-word-limit-value {
      font-weight: bold;
      margin-right: 5px;
    }

    .cod-word-limit-desc {
      font-size: 0.85rem;
      color: #aaa;
    }

    /* CoD examples section */
    .cod-examples {
      margin-top: 15px;
      padding: 15px;
      background-color: #2a2a2a;
      border-radius: 8px;
      border: 1px solid #444;
    }

    .cod-examples-header {
      font-size: 0.9rem;
      font-weight: bold;
      margin-bottom: 10px;
      color: #ddd;
      border-bottom: 1px solid #444;
      padding-bottom: 5px;
    }

    .cod-example-item {
      margin-bottom: 12px;
      font-family: 'Roboto Mono', monospace;
      font-size: 0.85rem;
      padding: 8px;
      background-color: #333;
      border-radius: 5px;
      color: #bbb;
    }

    .cod-example-question {
      color: #aaa;
      margin-bottom: 5px;
    }

    .cod-example-answer {
      color: #4a8cff;
    }
    
    /* Word count breakdown */
    .word-count-breakdown {
      font-size: 0.7rem;
      color: #aaa;
      margin-top: 3px;
      display: flex;
      gap: 8px;
    }

    .count-item {
      display: flex;
      align-items: center;
    }

    .count-thinking {
      color: #b7c9db;
    }

    .count-answer {
      color: #90cdf4;
    }
    
    /* NEW STYLING: Enhanced reasoning features */
    .advanced-options-header {
      font-size: 0.95rem;
      font-weight: 500;
      margin: 15px 0 8px 0;
      color: #ddd;
      border-bottom: 1px solid #444;
      padding-bottom: 5px;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    
    .toggle-switch {
      position: relative;
      display: inline-block;
      width: 44px;
      height: 22px;
    }
    
    .toggle-switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }
    
    .toggle-slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #555;
      transition: .4s;
      border-radius: 22px;
    }
    
    .toggle-slider:before {
      position: absolute;
      content: "";
      height: 16px;
      width: 16px;
      left: 3px;
      bottom: 3px;
      background-color: white;
      transition: .4s;
      border-radius: 50%;
    }
    
    input:checked + .toggle-slider {
      background-color: #4a8cff;
    }
    
    input:checked + .toggle-slider:before {
      transform: translateX(22px);
    }
    
    .enhanced-reasoning {
      background-color: #2a3746;
      border: 1px solid #3d4e63;
      border-radius: 8px;
      padding: 12px;
      margin-top: 10px;
    }
    
    .enhanced-reasoning-option {
      display: flex;
      align-items: center;
      margin-bottom: 8px;
    }
    
    .enhanced-reasoning-option input[type="radio"] {
      margin-right: 10px;
    }
    
    .option-description {
      margin-left: 25px;
      font-size: 0.8rem;
      color: #aaa;
      margin-bottom: 10px;
    }
    
    .complexity-indicator {
      display: flex;
      margin-top: 15px;
      margin-bottom: 10px;
    }
    
    .complexity-level {
      display: flex;
      flex-direction: column;
      align-items: center;
      flex: 1;
    }
    
    .complexity-bar {
      height: 5px;
      background-color: #3d4e63;
      margin-top: 5px;
      border-radius: 2px;
      width: 100%;
    }
    
    .complexity-label {
      font-size: 0.75rem;
      color: #90cdf4;
    }
    
    .preset-type {
      display: inline-block;
      padding: 3px 8px;
      background-color: #2c3a4f;
      color: #90cdf4;
      border-radius: 12px;
      font-size: 0.7rem;
      margin-left: 8px;
    }
    
    /* Auto-detection indicator */
    .auto-detection-badge {
      display: inline-flex;
      align-items: center;
      background-color: #394e6a;
      color: #a3c5e9;
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 0.7rem;
      margin-left: 7px;
    }
    
    .auto-detection-badge .indicator {
      display: inline-block;
      width: 8px;
      height: 8px;
      background-color: #68d391;
      border-radius: 50%;
      margin-right: 4px;
    }
    
    /* Help panel for complex problems */
    .problem-analyzer {
      margin-top: 15px;
      background-color: #2a3746;
      border: 1px solid #3d4e63;
      border-radius: 8px;
      padding: 12px;
    }
    
    .analyzer-title {
      font-weight: 500;
      color: #90cdf4;
      margin-bottom: 10px;
      display: flex;
      align-items: center;
    }
    
    .analyzer-icon {
      margin-right: 6px;
      color: #68d391;
    }
    
    .analyzer-help {
      font-size: 0.85rem;
      color: #bbb;
      margin-bottom: 10px;
      line-height: 1.4;
    }

    /* Responsive adjustments */
    @media (max-width: 768px) {
      .app-container {
        flex-direction: column;
      }
      
      .sidebar {
        width: 100%;
        max-height: 200px;
      }
      
      .message {
        max-width: 85%;
      }
      
      .settings-row {
        flex-direction: column;
        gap: 10px;
      }
      /* Image upload styles */
.upload-container {
  position: relative;
  margin-right: 8px;
}

.upload-btn {
  background-color: #3a3a3a;
  color: #fff;
  border: none;
  border-radius: 8px;
  width: 36px;
  height: 36px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: background-color 0.3s ease;
}

.upload-btn:hover {
  background-color: #4a4a4a;
}

.image-preview {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  margin-bottom: 8px;
}

.image-preview-item {
  position: relative;
  width: 80px;
  height: 80px;
  border-radius: 8px;
  overflow: hidden;
  border: 1px solid #444;
}

.image-preview-item img {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.remove-image {
  position: absolute;
  top: 2px;
  right: 2px;
  background-color: rgba(0, 0, 0, 0.6);
  color: #fff;
  border: none;
  border-radius: 50%;
  width: 20px;
  height: 20px;
  font-size: 12px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
}

.image-in-message {
  max-width: 100%;
  max-height: 400px;
  border-radius: 8px;
  margin: 8px 0;
  border: 1px solid #444;
}
      // Add this to your styles in the <style> section
.upload-container {
  position: relative;
  margin-right: 8px;
}

.upload-btn {
  background-color: #3a3a3a;
  color: #fff;
  border: none;
  border-radius: 8px;
  width: 36px;
  height: 36px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: background-color 0.3s ease;
}

.upload-btn:hover {
  background-color: #4a4a4a;
}

.image-preview {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  margin: 8px 0;
  padding: 8px;
  background-color: #252525;
  border-radius: 8px;
  border: 1px solid #333;
}

.image-preview-item {
  position: relative;
  width: 80px;
  height: 80px;
  border-radius: 8px;
  overflow: hidden;
  border: 1px solid #444;
}

.image-preview-item img {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.remove-image {
  position: absolute;
  top: 2px;
  right: 2px;
  background-color: rgba(0, 0, 0, 0.6);
  color: #fff;
  border: none;
  border-radius: 50%;
  width: 20px;
  height: 20px;
  font-size: 12px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
}

.image-in-message {
  max-width: 100%;
  max-height: 400px;
  border-radius: 8px;
  margin: 8px 0;
  border: 1px solid #444;
}

// Replace existing image upload functionality with this improved version
let uploadedImages = [];

function setupImageUpload() {
  const uploadBtn = document.getElementById("imageUploadBtn");
  const uploadInput = document.getElementById("imageUpload");
  
  if (uploadBtn && uploadInput) {
    uploadBtn.addEventListener("click", () => {
      uploadInput.click();
    });
    
    uploadInput.addEventListener("change", handleImageUpload);
  }
}

function handleImageUpload(event) {
  const files = event.target.files;
  if (!files || files.length === 0) return;
  
  // Create preview container if it doesn't exist
  let previewContainer = document.querySelector(".image-preview");
  if (!previewContainer) {
    previewContainer = document.createElement("div");
    previewContainer.className = "image-preview";
    const chatMessages = document.getElementById("chatMessages");
    const chatInput = document.querySelector(".chat-input");
    chatInput.parentNode.insertBefore(previewContainer, chatInput);
  }
  
  // Process each file
  for (const file of files) {
    if (!file.type.startsWith("image/")) continue;
    
    const reader = new FileReader();
    reader.onload = function(e) {
      const imageData = e.target.result;
      const imageId = Date.now() + "_" + uploadedImages.length;
      
      // Add to uploaded images array
      uploadedImages.push({
        id: imageId,
        data: imageData,
        name: file.name
      });
      
      // Create preview element
      const previewItem = document.createElement("div");
      previewItem.className = "image-preview-item";
      previewItem.dataset.imageId = imageId;
      
      const img = document.createElement("img");
      img.src = imageData;
      previewItem.appendChild(img);
      
      const removeBtn = document.createElement("button");
      removeBtn.className = "remove-image";
      removeBtn.innerHTML = "×";
      removeBtn.addEventListener("click", () => removeImage(imageId));
      previewItem.appendChild(removeBtn);
      
      previewContainer.appendChild(previewItem);
    };
    reader.readAsDataURL(file);
  }
  
  // Reset file input
  event.target.value = "";
}

function removeImage(imageId) {
  // Remove from array
  uploadedImages = uploadedImages.filter(img => img.id !== imageId);
  
  // Remove preview
  const previewItem = document.querySelector(`.image-preview-item[data-image-id="${imageId}"]`);
  if (previewItem) {
    previewItem.remove();
  }
  
  // Remove container if empty
  const previewContainer = document.querySelector(".image-preview");
  if (previewContainer && previewContainer.children.length === 0) {
    previewContainer.remove();
  }
}

// IMPORTANT: Do NOT completely replace the existing sendMessage function.
// Instead, modify the existing one to handle images. Here's how:

// Modify the existing sendMessage function to handle images
async function sendMessage(message) {
  // NEW: Analyze problem complexity if enhanced reasoning is enabled
  if (ENHANCED_REASONING_ENABLED && REASONING_ENHANCEMENT === "adaptive") {
    analyzeProblemComplexity(message);
  }
  
  // Parse message for word count requirements
  const wordCountRequest = parseWordCountRequest(message);
  
  // NEW: Handle images if present
  let messageWithImages = message;
  let imagesToShow = "";
  
  if (uploadedImages.length > 0) {
    // Add images to display in UI
    imagesToShow = uploadedImages.map(img => 
      `<img src="${img.data}" alt="Uploaded image" class="image-in-message">`
    ).join('');
    
    // Format message with image descriptions for the API
    let imageDescriptions = uploadedImages.map((img, index) => 
      `[Image ${index + 1}: ${img.name}]`
    ).join('\n');
    
    messageWithImages = `${message}\n\n${imageDescriptions}`;
  }
  
  // Add the message to the thread with images for display
  addMessageToCurrentThread(message + imagesToShow, "user");

  if (!MODEL_NAME) {
    const errorMsg = "Error: Please set the Model Name in the Settings.";
    addMessageToCurrentThread(errorMsg, "bot");
    console.error(errorMsg);
    return;
  }

  addMessageToCurrentThread("Bot is typing...", "bot", true);
  const thread = threads.find(t => t.id === currentThreadId);
  const placeholderIndex = thread.messages.length - 1;

  // Build messages array with current settings and word count request
  const messagesForApi = buildMessagesForChat(wordCountRequest);
  
  // For now, we'll use a simpler approach - just add image descriptions to the text
  // rather than trying to send actual images to the API
  if (uploadedImages.length > 0 && messagesForApi.length > 0) {
    // Find the last user message and append image descriptions
    for (let i = messagesForApi.length - 1; i >= 0; i--) {
      if (messagesForApi[i].role === 'user') {
        // We already included the image descriptions in messageWithImages
        messagesForApi[i].content = messageWithImages;
        break;
      }
    }
  }

  // Create payload
  const payload = {
    model: MODEL_NAME,
    max_tokens: MAX_TOKENS,
    top_p: TOP_P,
    top_k: TOP_K,
    presence_penalty: PRESENCE_PENALTY,
    frequency_penalty: FREQUENCY_PENALTY,
    temperature: TEMPERATURE,
    messages: messagesForApi
  };
  
  // Clear uploaded images after sending
  uploadedImages = [];
  const previewContainer = document.querySelector(".image-preview");
  if (previewContainer) {
    previewContainer.remove();
  }
  
  console.log(`Sending request with ${REASONING_METHOD} reasoning ${REASONING_METHOD === "cod" ? `(word limit: ${COD_WORD_LIMIT})` : ""}`);
  if (wordCountRequest) {
    console.log(`Final answer word limit requested: ${wordCountRequest} words`);
  }
  console.log(`Parameters: temp=${TEMPERATURE}, top_p=${TOP_P}, top_k=${TOP_K}`);

  try {
    // Add timestamp to URL to prevent caching
    const timestamp = new Date().getTime();
    const cacheBuster = `?t=${timestamp}`;
    
    const response = await fetch(`${API_PROXY_URL}${cacheBuster}`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify(payload)
    });
    
    if (!response.ok) {
      throw new Error(`HTTP error! Status: ${response.status}`);
    }
    
    const data = await response.json();
    const botReply = data.choices &&
                     data.choices[0] &&
                     data.choices[0].message &&
                     data.choices[0].message.content;
    if (botReply) {
      const trimmedReply = botReply.trim();
      
      // Create response metadata
      let reasoningInfo = REASONING_METHOD.toUpperCase();
      if (REASONING_METHOD === "cod") {
        reasoningInfo += `-${COD_WORD_LIMIT}`;
      }
      
      // Add enhanced reasoning info if used
      if (ENHANCED_REASONING_ENABLED && 
          REASONING_ENHANCEMENT === "adaptive" && 
          PROBLEM_COMPLEXITY.complexity === "complex") {
        reasoningInfo += "-ENHANCED";
      }
      
      // Process bot message to separate thinking and answer parts
      const processed = processBotMessage(trimmedReply, REASONING_METHOD);
      
      thread.messages[placeholderIndex] = {
        content: trimmedReply,
        sender: "bot",
        isPlaceholder: false,
        timestamp: new Date(),
        wordCount: (processed.thinkingWordCount || 0) + (processed.answerWordCount || 0),
        reasoningMethod: reasoningInfo,
        thinking: processed.thinking,
        answer: processed.answer,
        thinkingWordCount: processed.thinkingWordCount || 0,
        answerWordCount: processed.answerWordCount || 0
      };
    } else {
      thread.messages[placeholderIndex] = {
        content: "No valid response received. Check model name and API key.",
        sender: "bot",
        isPlaceholder: false,
        timestamp: new Date(),
        wordCount: 0,
        reasoningMethod: REASONING_METHOD.toUpperCase(),
        thinking: null,
        answer: null,
        thinkingWordCount: 0,
        answerWordCount: 0
      };
    }
  } catch (error) {
    console.error("Error communicating with API:", error);
    
    // Provide more detailed error message
    let errorMessage = "Error communicating with API: " + error.message;
    
    // Add suggestions based on error type
    if (error.message.includes("Failed to fetch")) {
      errorMessage += "\n\nPossible solutions:\n1. Make sure your API key is set correctly in Netlify\n2. Check that your model name is valid\n3. Verify your internet connection";
    }
    
    thread.messages[placeholderIndex] = {
      content: errorMessage,
      sender: "bot",
      isPlaceholder: false,
      timestamp: new Date(),
      wordCount: 0,
      reasoningMethod: REASONING_METHOD.toUpperCase(),
      thinking: null,
      answer: null,
      thinkingWordCount: 0,
      answerWordCount: 0
    };
  }
  renderCurrentThreadMessages();
}

// Modify the init function to include the image upload setup
function init() {
  console.log("Initializing app...");
  
  try {
    loadPersistedSettings();
    console.log("Settings loaded");
    
    // Update CoD prompt with the correct word limit
    updateCoDPrompt();
    console.log("CoD prompt updated");
    
    createNewThread();
    console.log("New thread created");
    
    initEventListeners();
    console.log("Event listeners initialized");
    
    // Setup image upload functionality
    setupImageUpload();
    console.log("Image upload functionality initialized");
    
    updateCurrentModelDisplay();
    console.log("Model display updated");
    
    // Initialize feedback form
    initFeedbackForm();
    console.log("Feedback form initialized");
    
    // Helper function to create a button that resets the thread
    function createClearThreadButton() {
      const clearThreadBtn = document.createElement("button");
      clearThreadBtn.id = "clearThreadBtn";
      clearThreadBtn.textContent = "Clear Thread";
      clearThreadBtn.style.marginTop = "0.5rem";
      clearThreadBtn.style.backgroundColor = "#553333";
      clearThreadBtn.addEventListener("click", () => {
        if (confirm("Clear all messages in this thread?")) {
          const thread = threads.find(t => t.id === currentThreadId);
          if (thread) {
            thread.messages = [];
            renderCurrentThreadMessages();
            showNotification("Thread cleared");
          }
        }
      });
      return clearThreadBtn;
    }
    
    // Add clear thread button to the sidebar
    const sidebar = document.querySelector(".sidebar");
    if (sidebar) {
      sidebar.appendChild(createClearThreadButton());
    }
    
    // If we don't have a model name, open settings modal
    if (!MODEL_NAME) {
      console.log("No model name found, opening settings");
      setTimeout(() => {
        try {
          openSettingsModal();
          console.log("Settings modal opened");
        } catch (err) {
          console.error("Error opening settings modal:", err);
        }
      }, 1000);
    }
  } catch (err) {
    console.error("Initialization error:", err);
  }
}
    }
  </style>
</head>
<body>
  <!-- Include jsPDF for PDF generation -->
  <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>

  <div class="app-container">
    <!-- Sidebar for Thread Management -->
    <div class="sidebar">
      <h2>Threads</h2>
      <ul id="threadList"></ul>
      <button id="newThreadBtn">New Thread</button>
      <button id="deleteThreadBtn">Delete Thread</button>
      <button id="downloadTxtBtn">Download TXT</button>
      <button id="downloadPdfBtn">Download PDF</button>
    </div>

    <!-- Chat Area -->
    <div class="chat-container">
      <div class="chat-header">
        <h1 id="pageTitle">LLM Playground (COT vs COD)</h1>
        <div>
          <span id="currentModelDisplay" class="current-model-display">Model not set</span>
          <button class="settings-btn" id="openSettings">Settings ⚙️</button>
        </div>
      </div>
      <div class="chat-messages" id="chatMessages">
        <!-- Chat messages will be rendered here -->
      </div>
      <!-- Add this right before the send button in the chat-input div -->
      <!-- Add this to your chat-input div in index.html -->
<div class="chat-input">
  <div class="upload-container">
    <button id="imageUploadBtn" class="upload-btn" title="Upload Image">
      <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
        <circle cx="8.5" cy="8.5" r="1.5"></circle>
        <polyline points="21 15 16 10 5 21"></polyline>
      </svg>
    </button>
    <input type="file" id="imageUpload" accept="image/*" style="display: none;">
  </div>
  <textarea id="userInput" rows="5" placeholder="Type your message..."></textarea>
  <button id="sendBtn">Send</button>
</div>

  <!-- Status Notification -->
  <div id="statusNotification" class="status-notification"></div>

  <!-- Settings Modal -->
  <div id="settingsModal" class="modal">
    <div class="modal-content">
      <button class="close-modal" id="closeModalX">&times;</button>
      <h2>Settings</h2>
      
      <div class="settings-tabs">
        <button class="tab-btn active" data-tab="modelTab">Model</button>
        <button class="tab-btn" data-tab="reasoningTab">Reasoning</button>
        <button class="tab-btn" data-tab="parametersTab">Parameters</button>
      </div>
      
      <!-- Model Selection Tab -->
      <div id="modelTab" class="tab-content active">
        <div class="settings-section-header">Model Configuration</div>
        <label for="modelName">Model Name/Path</label>
        <input type="text" id="modelName" placeholder="Enter full model name/path from Fireworks.ai">
        <p style="font-size: 0.8rem; color: #aaa; margin-top: 0; margin-bottom: 15px;">Enter the complete model identifier as used in Fireworks.ai API.</p>
        
        <button id="setModelBtn">Set Model</button>
      </div>
      
      <!-- Reasoning Tab -->
      <div id="reasoningTab" class="tab-content">
        <div class="settings-section-header">Reasoning Method</div>
        <div class="feature-section">
          <div class="radio-options">
            <div class="radio-option">
              <input type="radio" id="standardReasoning" name="reasoningMethod" value="standard">
              <label for="standardReasoning">Standard (No special prompt)</label>
              <div class="tooltip">?
                <span class="tooltiptext">Default model behavior with no special reasoning instructions.</span>
              </div>
            </div>
            
            <div class="radio-option">
              <input type="radio" id="cotReasoning" name="reasoningMethod" value="cot">
              <label for="cotReasoning">Chain of Thought (CoT)</label>
              <div class="tooltip">?
                <span class="tooltiptext">Instructs the model to think step-by-step to solve problems. Improves reasoning but uses more tokens.</span>
              </div>
            </div>
            
            <div class="radio-option">
              <input type="radio" id="codReasoning" name="reasoningMethod" value="cod" checked>
              <label for="codReasoning">Chain of Draft (CoD)</label>
              <div class="tooltip">?
                <span class="tooltiptext">Uses minimal words per step (research paper approach) to reduce token usage while maintaining reasoning quality.</span>
              </div>
            </div>
          </div>
          
          <!-- COD Word Limit options -->
          <div id="codOptions" class="cod-options">
            <!-- This will be populated by the updateCoDOptionsUI function -->
          </div>
        </div>
        
        <!-- NEW: Enhanced Reasoning Controls -->
        <div class="advanced-options-header">
          Advanced Reasoning Options
          <label class="toggle-switch">
            <input type="checkbox" id="enhancedReasoningToggle" checked>
            <span class="toggle-slider"></span>
          </label>
        </div>
        
        <div id="enhancedReasoningOptions" class="enhanced-reasoning">
          <div class="enhanced-reasoning-option">
            <input type="radio" id="adaptiveReasoning" name="reasoningEnhancement" value="adaptive" checked>
            <label for="adaptiveReasoning">Adaptive Reasoning</label>
            <span class="auto-detection-badge"><span class="indicator"></span>Auto</span>
          </div>
          <div class="option-description">
            Automatically increases reasoning depth for complex problems (math, logic, multi-step reasoning).
          </div>
          
          <div class="enhanced-reasoning-option">
            <input type="radio" id="standardReasoning" name="reasoningEnhancement" value="standard">
            <label for="standardReasoning">Fixed Reasoning Depth</label>
          </div>
          <div class="option-description">
            Uses the same reasoning approach for all problems regardless of complexity.
          </div>
          
          <div class="problem-analyzer">
            <div class="analyzer-title">
              <span class="analyzer-icon">🔍</span> Problem Complexity Detection
            </div>
            <div class="analyzer-help">
              When adaptive reasoning is enabled, the system will automatically analyze your questions to detect:
              <ul style="margin-top: 5px; padding-left: 20px; font-size: 0.85rem;">
                <li>Mathematical expressions and calculations</li>
                <li>Multi-step reasoning requirements</li>
                <li>Logical dependencies and constraints</li>
                <li>Complex or abstract concepts</li>
              </ul>
              For complex problems, the model will use more detailed reasoning steps even with CoD.
            </div>
          </div>
        </div>
      </div>
      
      <!-- Parameters Tab -->
      <div id="parametersTab" class="tab-content">
        <div class="settings-section-header">Generation Parameters</div>
        
        <!-- Improved range sliders with visible values -->
        <label for="temp">Temperature</label>
        <div class="range-container">
          <input type="range" id="temp" min="0" max="1" step="0.01" value="0.5">
          <span id="tempValue" class="range-value">0.5</span>
        </div>
        <p style="font-size: 0.8rem; color: #aaa; margin-top: 0;">Controls randomness: lower values make responses more focused and deterministic.</p>

        <label for="topP">Top P</label>
        <div class="range-container">
          <input type="range" id="topP" min="0" max="1" step="0.01" value="0.90">
          <span id="topPValue" class="range-value">0.90</span>
        </div>
        <p style="font-size: 0.8rem; color: #aaa; margin-top: 0;">Controls diversity via nucleus sampling: lower values exclude less probable tokens.</p>

        <label for="topK">Top K</label>
        <div class="range-container">
          <input type="range" id="topK" min="0" max="100" step="1" value="55">
          <span id="topKValue" class="range-value">55</span>
        </div>
        <p style="font-size: 0.8rem; color: #aaa; margin-top: 0;">Limits sampling to the top K most likely tokens.</p>

        <label for="maxTokens">Max Tokens</label>
        <div class="range-container">
          <input type="range" id="maxTokens" min="256" max="4096" step="128" value="1112">
          <span id="maxTokensValue" class="range-value">1112</span>
        </div>
        <p style="font-size: 0.8rem; color: #aaa; margin-top: 0;">Maximum number of tokens to generate in the response.</p>

        <label for="presencePenalty">Presence Penalty</label>
        <div class="range-container">
          <input type="range" id="presencePenalty" min="-2" max="2" step="0.1" value="0">
          <span id="presencePenaltyValue" class="range-value">0</span>
        </div>
        <p style="font-size: 0.8rem; color: #aaa; margin-top: 0;">Penalizes new tokens based on their presence in the input.</p>

        <label for="frequencyPenalty">Frequency Penalty</label>
        <div class="range-container">
          <input type="range" id="frequencyPenalty" min="-2" max="2" step="0.1" value="0.4">
          <span id="frequencyPenaltyValue" class="range-value">0.4</span>
        </div>
        <p style="font-size: 0.8rem; color: #aaa; margin-top: 0;">Penalizes tokens based on their frequency in the generated text.</p>
      </div>
      
      <div style="text-align: right; margin-top: 20px;">
        <button id="saveSettings">Save</button>
        <button id="closeSettings">Cancel</button>
      </div>
    </div>
  </div>

  <!-- Feedback Button and Modal -->
  <div style="position: fixed; bottom: 20px; left: 20px; z-index: 1000;">
    <button id="openFeedbackBtn" style="background-color: #4a8cff; color: white; border: none; padding: 10px 15px; border-radius: 20px; cursor: pointer; box-shadow: 0 2px 5px rgba(0,0,0,0.3);">
      <span style="margin-right: 5px;">💬</span> Feedback
    </button>
  </div>

  <div id="feedbackModal" class="modal">
    <div class="modal-content" style="max-width: 500px;">
      <button class="close-modal" id="closeFeedbackModal">&times;</button>
      <h2>Share Your Feedback</h2>
      
      <form name="feedback" method="POST" data-netlify="true">
        <input type="hidden" name="form-name" value="feedback">
        
        <input type="hidden" id="feedbackModel" name="model">
        <input type="hidden" id="feedbackReasoning" name="reasoning_method">
        
        <label for="feedbackType">Feedback Type:</label>
        <select id="feedbackType" name="feedback_type" style="width: 100%; margin-bottom: 15px;">
          <option value="general">General Feedback</option>
          <option value="bug">Report a Bug</option>
          <option value="feature">Feature Request</option>
          <option value="model_performance">Model Performance</option>
        </select>
        
        <label>How would you rate your experience?</label>
        <div style="display: flex; justify-content: space-between; margin: 10px 0 15px 0;">
          <label style="flex: 1; text-align: center;">
            <input type="radio" name="rating" value="1" required>
            <div>😞</div>
            <div style="font-size: 0.8rem;">Poor</div>
          </label>
          <label style="flex: 1; text-align: center;">
            <input type="radio" name="rating" value="2">
            <div>😐</div>
            <div style="font-size: 0.8rem;">Fair</div>
          </label>
          <label style="flex: 1; text-align: center;">
            <input type="radio" name="rating" value="3">
            <div>🙂</div>
            <div style="font-size: 0.8rem;">Good</div>
          </label>
          <label style="flex: 1; text-align: center;">
            <input type="radio" name="rating" value="4">
            <div>😀</div>
            <div style="font-size: 0.8rem;">Great</div>
          </label>
          <label style="flex: 1; text-align: center;">
            <input type="radio" name="rating" value="5">
            <div>🤩</div>
            <div style="font-size: 0.8rem;">Excellent</div>
          </label>
        </div>
        
        <label for="feedbackComments">Comments:</label>
        <textarea 
          id="feedbackComments" 
          name="comments" 
          rows="4" 
          style="width: 100%; background-color: #2e2e2e; color: #fff; border: 1px solid #444; border-radius: 5px; padding: 10px; margin-bottom: 20px;"
          required
        ></textarea>
        
        <button 
          type="submit" 
          style="background-color: #4a8cff; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; float: right;"
        >
          Submit Feedback
        </button>
      </form>
    </div>
  </div>

  <script>
    /***********************
     * Global Configuration
     ***********************/
    let MODEL_NAME = "";
    let MODEL_NAME_DISPLAY = "";
    
    // Server endpoint (Netlify serverless function)
    const API_PROXY_URL = "/.netlify/functions/api-proxy";
    
    // Reasoning Method
    let REASONING_METHOD = "cod"; // Options: "standard", "cot", "cod"
    
    // COD Word Limit
    let COD_WORD_LIMIT = 5;
    
    // NEW: Enhanced reasoning controls
    let ENHANCED_REASONING_ENABLED = true;
    let REASONING_ENHANCEMENT = "adaptive"; // Options: "adaptive", "standard"
    
    // NEW: Problem complexity detection
    let PROBLEM_COMPLEXITY = {
      hasMath: false,
      hasLogic: false,
      multiStep: false,
      complexity: "normal" // Options: "simple", "normal", "complex"
    };
    
    // Prompts for different reasoning methods
    let PROMPTS = {
      standard: "",
      
      cot: `Think step by step to solve this problem. Explain your reasoning at each step, then provide your final answer.`,
      
      cod: `Think step by step, but produce only minimal notes for each step (${COD_WORD_LIMIT} words maximum per step). Use mathematical notation where possible. Keep only essential information needed to solve the problem. Focus on key calculations and intermediate results without narrative explanation.
  
Separate your steps with periods. Write your final answer after the #### separator.

Examples:
Q: Jason had 20 lollipops. He gave Denny some lollipops. Now Jason has 12 lollipops. How many lollipops did Jason give to Denny?
A: 20 initial. 12 remaining. 20 - 12 = 8. #### 8 lollipops

Q: Roger has $125. He spends $55 on a video game and then receives $25 for his birthday. How much money does Roger have now?
A: Start: $125. Spent: $55. 125 - 55 = $70. Received: $25. 70 + 25 = $95. #### $95

Q: A square has a perimeter of 20 cm. What is its area?
A: Perimeter = 20 cm. Side length = 20/4 = 5 cm. Area = 5² = 25 cm². #### 25 square centimeters

Q: If a fabric store received 45 yards of cotton material and used 2/9 of it for a bulk order, how many yards of cotton material does the fabric store have left?
A: Total: 45 yards. Used: 2/9 × 45 = 10 yards. Remaining: 45 - 10 = 35 yards. #### 35 yards

Q: The temperature on Monday was -3°C. On Tuesday, it was 14°C. What was the change in temperature from Monday to Tuesday?
A: Monday: -3°C. Tuesday: 14°C. Change: 14 - (-3) = 17°C. #### 17°C`
    };
    
    // NEW: Enhanced prompts for complex problems with different word limits
    let ENHANCED_PROMPTS = {
      cot: `Think step by step to solve this problem. This appears to be a complex problem that requires careful reasoning. Break down your thinking into clear steps, making sure to consider all relevant information and constraints. 

For complex problems, use as many steps as needed to work through the solution thoroughly. It's better to use more steps with clear reasoning than to skip steps.

Check your calculations and logic at each step. After you've completed your reasoning process, provide your final answer.`,
      
      cod5: `Think step by step to solve this complex problem. For each step, use at most 5 words to capture the essential reasoning, but use AS MANY STEPS as needed to thoroughly work through the problem. Use mathematical notation where efficient. Show ALL intermediate calculations and logical inferences.

IMPORTANT: Instead of trying to fit complex reasoning into fewer steps, break your reasoning into more numerous simple steps. For example, instead of one step with "Calculate area using length×width=50×30=1500", use multiple steps:
1. Length = 50.
2. Width = 30.
3. Area = length × width.
4. Area = 50 × 30.
5. Area = 1500.

Separate your steps with periods. Write your final answer after the #### separator.

Example of solving a complex problem with sufficient steps:
Q: A car travels at 60 mph. After 2 hours, it increases speed to 75 mph for 1 hour. It then decreases to 50 mph for the final 30 minutes. What is the total distance traveled?
A: First segment: speed 60 mph. First segment: time 2h. First segment: distance = 60 × 2. First segment: distance = 120 miles. Second segment: speed 75 mph. Second segment: time 1h. Second segment: distance = 75 × 1. Second segment: distance = 75 miles. Third segment: speed 50 mph. Third segment: time 0.5h. Third segment: distance = 50 × 0.5. Third segment: distance = 25 miles. Total distance: 120 + 75 + 25. Total distance = 220 miles. #### 220 miles`,

      cod10: `Think step by step to solve this complex problem. For each step, use up to 10 words to capture the essential reasoning. Use AS MANY STEPS as needed to fully solve the problem. Include ALL intermediate calculations and logical inferences.

IMPORTANT: For complex problems, it's better to use more steps with clear reasoning than to try cramming too much into each step. Break complex calculations into multiple steps.

When thinking through difficult parts of a problem:
1. Identify what information you need
2. Think about how to derive that information
3. Perform calculations systematically
4. Check your work at key points

Separate your steps with periods. Write your final answer after the #### separator.

Example of solving a complex problem:
Q: A car travels at 60 mph. After 2 hours, it increases speed to 75 mph for 1 hour. It then decreases to 50 mph for the final 30 minutes. What is the total distance traveled?
A: First segment: speed 60 mph for 2 hours. First segment distance calculation: 60 mph × 2h. First segment distance = 120 miles. Second segment: speed 75 mph for 1 hour. Second segment distance calculation: 75 mph × 1h. Second segment distance = 75 miles. Third segment: speed 50 mph for 0.5 hours. Third segment distance calculation: 50 mph × 0.5h. Third segment distance = 25 miles. Need to sum all segment distances. Total distance calculation: 120 + 75 + 25. Total distance traveled = 220 miles. #### 220 miles`,
      
      cod15: `Think step by step to solve this complex problem. For each step, use up to 15 words to capture the essential reasoning, providing more detail for critical steps. Use mathematical notation where helpful but include explanations of your approach at key points.

Separate your steps with periods. Write your final answer after the #### separator.

Example of solving a complex problem:
Q: A car travels at 60 mph. After 2 hours, it increases speed to 75 mph for 1 hour. It then decreases to 50 mph for the final 30 minutes. What is the total distance traveled?
A: First segment: The car travels at 60 mph for 2 hours, so distance = 60 × 2 = 120 miles. Second segment: The car increases to 75 mph for 1 hour, so distance = 75 × 1 = 75 miles. Third segment: The car decreases to 50 mph for 0.5 hours, so distance = 50 × 0.5 = 25 miles. Total distance traveled = 120 + 75 + 25 = 220 miles. #### 220 miles`,
      
      cod17: `Think step by step to solve this complex problem. For each step, use up to 17 words to provide clear reasoning, especially for difficult parts. Balance precision and concision, using math notation to save words.

Separate your steps with periods. Write your final answer after the #### separator.

Example of solving a complex problem:
Q: A car travels at 60 mph. After 2 hours, it increases speed to 75 mph for 1 hour. It then decreases to 50 mph for the final 30 minutes. What is the total distance traveled?
A: First segment: The car travels at 60 mph for 2 hours, giving distance = 60 × 2 = 120 miles. Second segment: Speed increases to 75 mph for 1 hour, so this segment's distance = 75 miles. Third segment: Speed is 50 mph for 0.5 hours, contributing 50 × 0.5 = 25 miles. Total journey distance = 120 + 75 + 25 = 220 miles. #### 220 miles`,
      
      cod20: `Think step by step to solve this complex problem. For each step, use up to 20 words to provide clear reasoning, explaining your approach more thoroughly for the difficult parts of the problem.

Separate your steps with periods. Write your final answer after the #### separator.

Example of solving a complex problem:
Q: A car travels at 60 mph. After 2 hours, it increases speed to 75 mph for 1 hour. It then decreases to 50 mph for the final 30 minutes. What is the total distance traveled?
A: First segment: The car travels at 60 mph for 2 hours, so the distance covered in this segment is 60 × 2 = 120 miles. Second segment: The car then increases speed to 75 mph and maintains this for 1 hour, covering 75 × 1 = 75 miles. Third segment: Finally, the car decreases speed to 50 mph for 30 minutes (0.5 hours), covering 50 × 0.5 = 25 miles. Total distance traveled over the entire journey = 120 + 75 + 25 = 220 miles. #### 220 miles`
    };
    
    // Default generation parameters
    let TEMPERATURE = 0.5;
    let TOP_P = 0.90;
    let TOP_K = 55;
    let MAX_TOKENS = 1112;
    let PRESENCE_PENALTY = 0;
    let FREQUENCY_PENALTY = 0.4;

    function getModelDisplayName(fullStr) {
      if (!fullStr) return "Model not set";
      
      // Extract from path
      const parts = fullStr.split("/");
      const lastChunk = parts[parts.length - 1] || "";
      const dashIndex = lastChunk.lastIndexOf("-");
      if (dashIndex !== -1) {
        return lastChunk.substring(0, dashIndex);
      }
      return lastChunk;
    }
    
    function updateCurrentModelDisplay() {
      const element = document.getElementById("currentModelDisplay");
      if (element) {
        let displayText = getModelDisplayName(MODEL_NAME);
        
        // Add badge for reasoning method
        let reasoningBadge = "";
        switch (REASONING_METHOD) {
          case "cot":
            reasoningBadge = '<span class="reasoning-badge" style="background-color: #2c6b9c;">CoT</span>';
            break;
          case "cod":
            reasoningBadge = `<span class="reasoning-badge" style="background-color: #2c6b9c;">CoD-${COD_WORD_LIMIT}</span>`;
            break;
        }
        
        // Add enhanced reasoning badge if enabled
        if (ENHANCED_REASONING_ENABLED && REASONING_ENHANCEMENT === "adaptive") {
          reasoningBadge += '<span class="reasoning-badge" style="background-color: #2d5038; margin-left: 3px;">Adaptive</span>';
        }
        
        element.innerHTML = displayText + reasoningBadge;
      }
    }

    /***********************
     * Thread Management
     ***********************/
    let threads = [];
    let currentThreadId = null;
    let threadCounter = 1;

    function createNewThread() {
      const newThread = {
        id: Date.now(),
        name: `Thread ${threadCounter++}`,
        messages: []
      };
      threads.push(newThread);
      currentThreadId = newThread.id;
      updateThreadList();
      renderCurrentThreadMessages();
      
      // Show status notification
      showNotification("New thread created");
    }

    function updateThreadList() {
      const threadList = document.getElementById("threadList");
      threadList.innerHTML = "";
      threads.forEach(thread => {
        const li = document.createElement("li");
        li.textContent = thread.name;
        if (thread.id === currentThreadId) {
          li.classList.add("active");
        }
        li.addEventListener("click", () => {
          currentThreadId = thread.id;
          renderCurrentThreadMessages();
          updateThreadList();
        });
        threadList.appendChild(li);
      });
    }

    function deleteCurrentThread() {
      if (!currentThreadId) return;
      if (confirm("Are you sure you want to delete this thread?")) {
        threads = threads.filter(thread => thread.id !== currentThreadId);
        if (threads.length > 0) {
          currentThreadId = threads[0].id;
        } else {
          createNewThread();
          return;
        }
        updateThreadList();
        renderCurrentThreadMessages();
        showNotification("Thread deleted");
      }
    }

    /************************************************
     * Helper: Parse Content for Export
     ************************************************/
    function parseContentForExport(content) {
      const result = [];
      const segments = content.split(/```/);
      for (let i = 0; i < segments.length; i++) {
        if (i % 2 === 0) {
          // Normal text
          const textLines = segments[i].split(/\r?\n/);
          textLines.forEach(line => {
            result.push({ type: 'text', content: line });
          });
        } else {
          // Code block
          const codeSegment = segments[i].trim();
          const firstNewlineIndex = codeSegment.indexOf('\n');
          let language = '';
          let codeContent = codeSegment;
          if (firstNewlineIndex !== -1) {
            const possibleLang = codeSegment.substring(0, firstNewlineIndex).trim();
            if (possibleLang && !possibleLang.includes(' ')) {
              language = possibleLang;
              codeContent = codeSegment.substring(firstNewlineIndex + 1);
            }
          }
          const codeLines = codeContent.split(/\r?\n/);
          result.push({ type: 'code', language: language, content: codeLines });
        }
      }
      return result;
    }

    /***********************
     * Word Counting Utility - IMPROVED FOR COD
     ***********************/
    function countWords(text) {
      // Remove code blocks to get more accurate word count for actual text
      const textWithoutCode = text.replace(/```[\s\S]*?```/g, '');
      
      // Count mathematical expressions as single words
      // First, replace common math expressions with placeholder words
      let processedText = textWithoutCode
        // Replace simple equations (e.g., "x = 5 + 3") with single tokens
        .replace(/\b\w+\s*=\s*[\d\w+\-*/()]+/g, "EQUATION")
        // Replace fractions (e.g., "2/3") with single tokens
        .replace(/\b\d+\/\d+\b/g, "FRACTION")
        // Replace mathematical operations with spaces
        .replace(/[+\-*/=<>]+/g, " ");
      
      // Split by whitespace and filter out empty strings
      const words = processedText.split(/\s+/).filter(word => word.length > 0);
      return words.length;
    }

    /***********************
     * NEW: Problem Complexity Analysis
     ***********************/
    function analyzeProblemComplexity(message) {
      // Reset current complexity
      PROBLEM_COMPLEXITY = {
        hasMath: false,
        hasLogic: false,
        multiStep: false,
        complexity: "normal",
        wordCount: message.split(/\s+/).length, // Count words in the problem
        estimatedSteps: 0 // Will be calculated below
      };
      
      // Mathematical expressions and calculations
      const mathPatterns = [
        /[0-9\s][\+\-\*\/\=\(\)][0-9\s]/,  // Basic operations
        /\d+\s*\^\s*\d+/,                  // Powers
        /\d+\s*\/\s*\d+/,                  // Fractions
        /(?:sin|cos|tan|log|ln|sqrt|exp)/i, // Math functions
        /\[\s*[^\]]+\s*\]/,                // Matrix notation
        /\{\s*[^\}]+\s*\}/,                // Set notation
        /[\+\-]\s*[\d\.]+[eE][\+\-]\d+/,   // Scientific notation
        /\d+\s*%/,                         // Percentages
      ];
      
      // Logical expressions
      const logicPatterns = [
        /(?:if|then|else|therefore|because|implies|since|hence|thus|consequently)/i,
        /(?:and|or|not|xor|nor|all|some|every|any|none)/i,
        /(?:true|false|valid|invalid|prove|QED|contradiction|logical|premise|conclusion)/i,
      ];
      
      // Indicators of multi-step problems
      const multiStepPatterns = [
        /(?:first|second|third|next|then|after|finally|lastly|step|phase)/i,
        /(?:find the total|calculate the|determine the|solve for)/i,
        /(?:per month|per year|initially|eventually|ultimately|before|after)/i,
        /(?:increases by|decreases by|changes by|grows|reduces)/i,
      ];
      
      // Check for math patterns
      for (const pattern of mathPatterns) {
        if (pattern.test(message)) {
          PROBLEM_COMPLEXITY.hasMath = true;
          break;
        }
      }
      
      // Check for logic patterns
      for (const pattern of logicPatterns) {
        if (pattern.test(message)) {
          PROBLEM_COMPLEXITY.hasLogic = true;
          break;
        }
      }
      
      // Check for multi-step patterns
      for (const pattern of multiStepPatterns) {
        if (pattern.test(message)) {
          PROBLEM_COMPLEXITY.multiStep = true;
          break;
        }
      }
      
      // Determine complexity
      let complexityScore = 0;
      if (PROBLEM_COMPLEXITY.hasMath) complexityScore += 1;
      if (PROBLEM_COMPLEXITY.hasLogic) complexityScore += 1;
      if (PROBLEM_COMPLEXITY.multiStep) complexityScore += 1;
      
      // Apply more specific pattern checks
      
      // Advanced math indicators
      if (/(?:calculus|differential|integral|equation system|probability|statistics|algebra|geometry)/i.test(message)) {
        complexityScore += 1;
      }
      
      // Long problems are often complex
      if (message.length > 500) {
        complexityScore += 1;
      }
      
      // Multiple constraints or variables
      if (message.match(/(?:constraint|variable|unknown|factor|parameter|condition)/gi)?.length > 2) {
        complexityScore += 1;
      }
      
      // Update complexity level
      if (complexityScore >= 3) {
        PROBLEM_COMPLEXITY.complexity = "complex";
        // Estimate number of steps needed based on problem length and complexity
        PROBLEM_COMPLEXITY.estimatedSteps = Math.max(
          5, 
          Math.min(20, Math.ceil(PROBLEM_COMPLEXITY.wordCount / 15))
        );
      } else if (complexityScore >= 1) {
        PROBLEM_COMPLEXITY.complexity = "normal";
        PROBLEM_COMPLEXITY.estimatedSteps = Math.max(
          3, 
          Math.min(10, Math.ceil(PROBLEM_COMPLEXITY.wordCount / 20))
        );
      } else {
        PROBLEM_COMPLEXITY.complexity = "simple";
        PROBLEM_COMPLEXITY.estimatedSteps = Math.max(
          2, 
          Math.min(5, Math.ceil(PROBLEM_COMPLEXITY.wordCount / 25))
        );
      }
      
      // Adjust the estimated steps based on problem characteristics
      if (PROBLEM_COMPLEXITY.hasMath && PROBLEM_COMPLEXITY.multiStep) {
        PROBLEM_COMPLEXITY.estimatedSteps += 2; // Add more steps for multi-step math problems
      }
      
      if (PROBLEM_COMPLEXITY.hasLogic) {
        PROBLEM_COMPLEXITY.estimatedSteps += 1; // Add more steps for logical reasoning
      }
      
      // If the problem has math expressions, ensure minimum steps
      if (PROBLEM_COMPLEXITY.hasMath) {
        PROBLEM_COMPLEXITY.estimatedSteps = Math.max(PROBLEM_COMPLEXITY.estimatedSteps, 4);
      }
      
      console.log(`Problem analysis: ${JSON.stringify(PROBLEM_COMPLEXITY)}`);
      
      return PROBLEM_COMPLEXITY;
    }

    /***********************
     * Parse User Message for Word Count Requirements
     ***********************/
    function parseWordCountRequest(message) {
      // Common patterns for word count requests
      const patterns = [
        /(\d+)\s*words?/i, // Matches: "50 words", "100 word", etc.
        /in\s*(\d+)\s*words/i, // Matches: "in 50 words", "in 100 words"
        /limit\s*(\d+)\s*words/i, // Matches: "limit 50 words", "limit to 100 words"
        /answer\s*in\s*(\d+)\s*words/i, // Matches: "answer in 50 words"
        /respond\s*in\s*(\d+)\s*words/i, // Matches: "respond in 50 words"
        /keep\s*it\s*to\s*(\d+)\s*words/i, // Matches: "keep it to 50 words"
        /no\s*more\s*than\s*(\d+)\s*words/i, // Matches: "no more than 50 words"
        /under\s*(\d+)\s*words/i, // Matches: "under 50 words"
        /maximum\s*of\s*(\d+)\s*words/i, // Matches: "maximum of 50 words"
        /max\s*(\d+)\s*words/i // Matches: "max 50 words"
      ];

      // Check each pattern
      for (const pattern of patterns) {
        const match = message.match(pattern);
        if (match && match[1]) {
          const wordCount = parseInt(match[1]);
          if (!isNaN(wordCount) && wordCount > 0) {
            return wordCount;
          }
        }
      }

      // No word count requirement found
      return null;
    }

    /***********************
     * Download as TXT
     ***********************/
    function downloadCurrentThreadAsTxt() {
      const thread = threads.find(t => t.id === currentThreadId);
      if (!thread) return;

      let content = `Model: ${MODEL_NAME_DISPLAY} (${REASONING_METHOD.toUpperCase()}`;
      if (REASONING_METHOD === "cod") {
        content += `-${COD_WORD_LIMIT}`;
      }
      content += `)\n\n`;

      thread.messages.forEach(msg => {
        const prefix = msg.sender.toUpperCase();
        
        // Add word count info for bot messages
        let headerInfo = prefix;
        if (msg.sender === "bot" && !msg.isPlaceholder && msg.wordCount !== undefined) {
          let countInfo = `[${msg.wordCount} words - ${msg.reasoningMethod || REASONING_METHOD.toUpperCase()}]`;
          if (msg.thinkingWordCount !== undefined && msg.answerWordCount !== undefined) {
            countInfo += ` (thinking: ${msg.thinkingWordCount}, answer: ${msg.answerWordCount})`;
          }
          headerInfo += ` ${countInfo}`;
        }
        
        content += `${headerInfo}:\n`;
        
        // Special handling for messages with thinking/answer components
        if (msg.sender === "bot" && msg.thinking && msg.answer) {
          content += `THINKING STEPS:\n${msg.thinking}\n\nFINAL ANSWER:\n${msg.answer}\n`;
        } else {
          const parsed = parseContentForExport(msg.content);
          parsed.forEach(item => {
            if (item.type === 'text') {
              content += item.content + '\n';
            } else if (item.type === 'code') {
              const lang = item.language ? ` (${item.language})` : '';
              content += `----- CODE BLOCK START${lang} -----\n`;
              item.content.forEach(line => {
                content += `  ${line}\n`;
              });
              content += `----- CODE BLOCK END -----\n`;
            }
          });
        }
        content += '\n';
      });

      const blob = new Blob([content], { type: "text/plain" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = `${thread.name}.txt`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      showNotification("TXT file downloaded");
    }

    /***********************
     * Download as PDF
     ***********************/
    async function downloadCurrentThreadAsPdf() {
      const thread = threads.find(t => t.id === currentThreadId);
      if (!thread) return;

      const { jsPDF } = window.jspdf;
      const doc = new jsPDF({
        unit: "pt",
        format: "letter"
      });

      function setPageBackground(doc) {
        doc.setFillColor(30, 30, 30);
        doc.rect(0, 0, doc.internal.pageSize.width, doc.internal.pageSize.height, 'F');
      }

      setPageBackground(doc);
      doc.setTextColor(224, 224, 224);

      let yPos = 40;
      const lineHeight = 14;
      const leftMargin = 40;

      doc.setFont("helvetica", "bold");
      doc.setFontSize(12);
      let modelInfo = `Model: ${MODEL_NAME_DISPLAY} (${REASONING_METHOD.toUpperCase()}`;
      if (REASONING_METHOD === "cod") {
        modelInfo += `-${COD_WORD_LIMIT}`;
      }
      modelInfo += `)`;
      doc.text(modelInfo, leftMargin, yPos);
      yPos += 20;
      doc.text(thread.name, leftMargin, yPos);
      yPos += 20;

      thread.messages.forEach(msg => {
        doc.setFont("helvetica", "bold");
        doc.setFontSize(10);
        
        // Add word count info for bot messages
        let sender = msg.sender.toUpperCase() + ":";
        if (msg.sender === "bot" && !msg.isPlaceholder && msg.wordCount !== undefined) {
          let countInfo = `[${msg.wordCount} words - ${msg.reasoningMethod || REASONING_METHOD.toUpperCase()}]`;
          if (msg.thinkingWordCount !== undefined && msg.answerWordCount !== undefined) {
            countInfo += ` (thinking: ${msg.thinkingWordCount}, answer: ${msg.answerWordCount})`;
          }
          sender += ` ${countInfo}`;
        }
        
        doc.text(sender, leftMargin, yPos);
        yPos += lineHeight;

        // Special handling for messages with thinking/answer components
        if (msg.sender === "bot" && !msg.isPlaceholder && (msg.thinking || msg.answer)) {
          // If we have thinking steps, render them
          if (msg.thinking) {
            doc.setFont("helvetica", "italic");
            doc.setFontSize(9);
            doc.setTextColor(180, 180, 180);
            doc.text("THINKING STEPS:", leftMargin, yPos);
            yPos += lineHeight;
            
            doc.setFont("courier", "normal");
            const thinkingLines = msg.thinking.split(/\r?\n/);
            thinkingLines.forEach(line => {
              if (yPos > 720) {
                doc.addPage();
                setPageBackground(doc);
                yPos = 40;
              }
              const wrapped = doc.splitTextToSize(line, 520);
              wrapped.forEach(wLine => {
                doc.text(wLine, leftMargin + 10, yPos);
                yPos += lineHeight;
              });
            });
            
            yPos += lineHeight/2;
          }
          
          // If we have an answer, render it
          if (msg.answer) {
            doc.setFont("helvetica", "bold");
            doc.setFontSize(9);
            doc.setTextColor(144, 205, 244);
            doc.text("FINAL ANSWER:", leftMargin, yPos);
            yPos += lineHeight;
            
            doc.setFont("helvetica", "normal");
            doc.setTextColor(224, 224, 224);
            doc.setFontSize(10);
            const answerLines = msg.answer.split(/\r?\n/);
            answerLines.forEach(line => {
              if (yPos > 720) {
                doc.addPage();
                setPageBackground(doc);
                yPos = 40;
              }
              const wrapped = doc.splitTextToSize(line, 520);
              wrapped.forEach(wLine => {
                doc.text(wLine, leftMargin + 10, yPos);
                yPos += lineHeight;
              });
            });
          }
        } else {
          // Standard rendering for other messages
          const parsed = parseContentForExport(msg.content);
          parsed.forEach(item => {
            if (item.type === 'text') {
              doc.setFont("helvetica", "normal");
              const line = item.content;
              if (yPos > 720) {
                doc.addPage();
                setPageBackground(doc);
                yPos = 40;
              }
              const wrapped = doc.splitTextToSize(line, 540);
              wrapped.forEach(wLine => {
                doc.text(wLine, leftMargin, yPos);
                yPos += lineHeight;
              });
            } else if (item.type === 'code') {
              doc.setFont("helvetica", "bold");
              const lang = item.language ? ` (${item.language})` : '';
              doc.text(`Code Block${lang}:`, leftMargin, yPos);
              yPos += lineHeight;

              doc.setFont("courier", "normal");
              item.content.forEach(codeLine => {
                if (yPos > 720) {
                  doc.addPage();
                  setPageBackground(doc);
                  yPos = 40;
                }
                const wrapped = doc.splitTextToSize(codeLine, 520);
                wrapped.forEach(wLine => {
                  doc.text(wLine, leftMargin + 20, yPos);
                  yPos += lineHeight;
                });
              });
            }
          });
        }
        yPos += lineHeight;
      });

      doc.save(`${thread.name}.pdf`);
      showNotification("PDF file downloaded");
    }

    /***********************
     * Process Bot Messages - IMPROVED VERSION FOR COD
     ***********************/
    function processBotMessage(content, reasoningMethod) {
      // For Chain of Draft (CoD) mode, extract thinking steps and final answer
      if (reasoningMethod === "cod") {
        const separatorIndex = content.indexOf("####");
        
        if (separatorIndex !== -1) {
          // Extract thinking steps and final answer
          let thinking = content.substring(0, separatorIndex).trim();
          let answer = content.substring(separatorIndex + 4).trim();
          
          return {
            content: content,
            thinking: thinking,
            answer: answer,
            thinkingWordCount: countWords(thinking),
            answerWordCount: countWords(answer)
          };
        } else {
          // Try to identify thinking steps and final answer based on structure
          // Look for phrases that might indicate a conclusion
          const conclusionPhrases = [
            "Therefore", "Thus", "Hence", "So", "Result", "Answer", "Finally", 
            "In conclusion", "The answer is", "This gives us"
          ];
          
          // Split by periods to identify steps
          const parts = content.split('.');
          if (parts.length > 1) {
            // Use the last part as the answer and everything else as thinking
            const lastPart = parts.pop().trim();
            const thinking = parts.join('.').trim();
            
            return {
              content: content,
              thinking: thinking,
              answer: lastPart,
              thinkingWordCount: countWords(thinking),
              answerWordCount: countWords(lastPart)
            };
          }
        }
      }
      
      // For Chain of Thought (CoT) mode, try to identify a logical final answer section
      if (reasoningMethod === "cot") {
        // Look for potential conclusion markers
        const conclusionMarkers = [
          "Therefore", "In conclusion", "So,", "Thus,", "Hence,", 
          "The answer is", "To conclude", "Finally,", "In summary",
          "As a result", "Consequently", "The final answer"
        ];
        
        // Add a marker for just "Answer:" or "Final answer:" on its own line
        const answerMarkers = [
          /\n(Answer:|Final answer:)/i,
          /^(Answer:|Final answer:)/i,
          /\n(The answer is:|My answer is:|Final answer is:)/i
        ];
        
        // Try each answer marker pattern
        for (const pattern of answerMarkers) {
          const answerMatch = content.match(pattern);
          if (answerMatch && answerMatch.index !== undefined) {
            // Found a marker
            const thinking = content.substring(0, answerMatch.index).trim();
            const answer = content.substring(answerMatch.index + answerMatch[0].length).trim();
            
            return {
              content: content,
              thinking: thinking,
              answer: answer,
              thinkingWordCount: countWords(thinking),
              answerWordCount: countWords(answer)
            };
          }
        }
        
        // If no explicit answer marker, look for conclusion indicator words
        let lastMarkerIndex = -1;
        let bestMarker = "";
        
        for (const marker of conclusionMarkers) {
          // Check for the marker near the end of the text (last 40%)
          const startSearchPos = content.length * 0.6;
          const markerIndex = content.indexOf(marker, startSearchPos);
          
          if (markerIndex > lastMarkerIndex && markerIndex !== -1) {
            lastMarkerIndex = markerIndex;
            bestMarker = marker;
          }
        }
        
        // If we found a conclusion marker in a reasonable position
        if (lastMarkerIndex > content.length * 0.6) {
          const thinking = content.substring(0, lastMarkerIndex).trim();
          const answer = content.substring(lastMarkerIndex).trim();
          
          return {
            content: content,
            thinking: thinking,
            answer: answer,
            thinkingWordCount: countWords(thinking),
            answerWordCount: countWords(answer)
          };
        }
        
        // Last resort: if text has multiple paragraphs, try to use the last paragraph as answer
        const paragraphs = content.split(/\n\s*\n/);
        if (paragraphs.length > 1) {
          const lastParagraph = paragraphs[paragraphs.length - 1].trim();
          // Only use last paragraph as answer if it's relatively short compared to whole text
          if (lastParagraph.length < content.length * 0.3) {
            const thinking = content.substring(0, content.lastIndexOf(lastParagraph)).trim();
            return {
              content: content,
              thinking: thinking,
              answer: lastParagraph,
              thinkingWordCount: countWords(thinking),
              answerWordCount: countWords(lastParagraph)
            };
          }
        }
      }
      
      // For standard reasoning
      if (reasoningMethod === "standard") {
        return {
          content: content,
          thinking: null, 
          answer: content,
          thinkingWordCount: 0,
          answerWordCount: countWords(content)
        };
      }
      
      // Default: if unable to separate, return entire content
      return {
        content: content,
        thinking: reasoningMethod === "cot" || reasoningMethod === "cod" ? content : null,
        answer: reasoningMethod === "standard" ? content : null,
        thinkingWordCount: reasoningMethod === "cot" || reasoningMethod === "cod" ? countWords(content) : 0,
        answerWordCount: reasoningMethod === "standard" ? countWords(content) : 0
      };
    }

    /***********************
     * Format Thinking Steps - IMPROVED FOR COD
     ***********************/
    function formatThinkingSteps(thinking, reasoningMethod) {
      if (!thinking) return '';
      
      // Remove any "###" prefixes
      let cleanedThinking = thinking.replace(/^#{1,3}\s*/gm, '');
      
      if (reasoningMethod === "cod") {
        // Split by periods to separate steps for CoD
        let steps = cleanedThinking.split(/\.\s*/).filter(step => step.trim().length > 0);
        
        // Create a more visually distinct format for CoD steps
        return steps.map((step, index) => 
          `<div class="step cod-step">
            <span class="step-number">${index + 1}</span>
            <span class="step-content">${step.trim()}${!step.endsWith('.') ? '.' : ''}</span>
          </div>`
        ).join('');
      } else {
        // Original formatting for CoT
        let steps = cleanedThinking.split(/\.\s+/);
        
        return steps.filter(step => step.trim())
          .map(step => 
            `<div class="step">${step.trim()}${!step.endsWith('.') ? '.' : ''}</div>`
          ).join('');
      }
    }

    /***********************
     * Transform Message
     ***********************/
    function transformMessage(content) {
      // Remove "###" prefixes from lines
      let processedContent = content.replace(/^#{1,3}\s*/gm, '');
      
      // Replace code blocks with syntax highlighting
      const transformed = processedContent.replace(/```([\s\S]*?)```/g, (match, codeContent) => {
        let language = '';
        const lines = codeContent.split('\n');
        if (lines.length > 0 && !lines[0].includes(' ')) {
          language = lines[0].trim();
          lines.shift();
        }
        return `<pre><code class="${language}">${lines.join('\n')}</code></pre>`;
      });
      return transformed;
    }

    /***********************
     * Rendering Messages - IMPROVED VERSION
     ***********************/
    function renderCurrentThreadMessages() {
      const chatMessagesDiv = document.getElementById("chatMessages");
      chatMessagesDiv.innerHTML = "";
      const thread = threads.find(t => t.id === currentThreadId);
      if (thread) {
        thread.messages.forEach(msg => {
          const messageDiv = document.createElement("div");
          messageDiv.classList.add("message", msg.sender);
          if (msg.isPlaceholder) {
            messageDiv.classList.add("placeholder");
          }

          const timestampStr = msg.timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
          const timestampEl = document.createElement("small");
          timestampEl.textContent = timestampStr;
          timestampEl.style.color = "#aaa";
          timestampEl.style.display = "block";
          timestampEl.style.marginBottom = "0.5rem";
          messageDiv.appendChild(timestampEl);

          // Special handling for messages with thinking/answer components
          if (msg.sender === "bot" && !msg.isPlaceholder) {
            const messageContainer = document.createElement("div");
            messageContainer.className = "message-container";
            
            // If we have thinking steps (for CoT or CoD)
            if (msg.thinking) {
              const thinkingDiv = document.createElement("div");
              thinkingDiv.className = "thinking-steps";
              
              // Add different style class for CoD
              if (msg.reasoningMethod && msg.reasoningMethod.startsWith("COD")) {
                thinkingDiv.classList.add("cod-thinking");
              }
              
              const thinkingLabel = document.createElement("div");
              thinkingLabel.className = "thinking-label";
              thinkingLabel.textContent = msg.reasoningMethod && msg.reasoningMethod.startsWith("COD") ? 
                "Chain of Draft Steps" : "Thinking Steps";
              thinkingDiv.appendChild(thinkingLabel);
              
              // Format thinking steps using the improved formatted steps function
              const thinkingContent = document.createElement("div");
              thinkingContent.innerHTML = formatThinkingSteps(
                msg.thinking, 
                msg.reasoningMethod ? msg.reasoningMethod.toLowerCase() : REASONING_METHOD
              );
              thinkingDiv.appendChild(thinkingContent);
              
              messageContainer.appendChild(thinkingDiv);
            }
            
            // If we have an answer (for CoD, CoT or Standard)
            if (msg.answer) {
              const answerDiv = document.createElement("div");
              answerDiv.className = "final-answer";
              
              const answerLabel = document.createElement("div");
              answerLabel.className = "final-answer-label";
              answerLabel.textContent = "Final Answer";
              answerDiv.appendChild(answerLabel);
              
              const answerContent = document.createElement("div");
              answerContent.innerHTML = transformMessage(msg.answer);
              answerDiv.appendChild(answerContent);
              
              messageContainer.appendChild(answerDiv);
            }
            
            // If we have neither thinking nor answer (fall back to content)
            if (!msg.thinking && !msg.answer) {
              const contentEl = document.createElement("div");
              contentEl.innerHTML = transformMessage(msg.content);
              messageContainer.appendChild(contentEl);
            }
            
            messageDiv.appendChild(messageContainer);
          } else {
            // Standard rendering for user messages or placeholders
            const contentEl = document.createElement("div");
            contentEl.innerHTML = transformMessage(msg.content);
            messageDiv.appendChild(contentEl);
          }
          
          // Add word count badge for bot messages (except placeholders)
          if (msg.sender === "bot" && !msg.isPlaceholder && msg.wordCount !== undefined) {
            const wordCountBadge = document.createElement("div");
            wordCountBadge.className = "word-count-badge";
            
            // Calculate token savings if we have CoD
            let badgeText = `${msg.wordCount} words - ${msg.reasoningMethod || REASONING_METHOD.toUpperCase()}`;
            
            wordCountBadge.innerHTML = badgeText;
            
            // Add breakdown of thinking vs answer word counts
            if (msg.thinkingWordCount !== undefined && msg.answerWordCount !== undefined) {
              wordCountBadge.innerHTML += `
                <div class="word-count-breakdown">
                  <span class="count-item count-thinking">thinking: ${msg.thinkingWordCount}</span>
                  <span class="count-item count-answer">answer: ${msg.answerWordCount}</span>
                </div>
              `;
            }
            
            // If this is a CoD message, add token savings estimate
            if (msg.reasoningMethod && msg.reasoningMethod.startsWith("COD") && thread.messages.length > 1) {
              // Find a similar CoT message (if available) to compare token savings
              const cotMessages = thread.messages.filter(m => 
                m.sender === "bot" && 
                m.reasoningMethod && 
                m.reasoningMethod === "COT" && 
                !m.isPlaceholder
              );
              
              if (cotMessages.length > 0) {
                // Calculate average token savings compared to CoT
                const avgCotWords = cotMessages.reduce((sum, m) => sum + m.wordCount, 0) / cotMessages.length;
                const savings = Math.round(100 - ((msg.wordCount / avgCotWords) * 100));
                
                if (savings > 0) {
                  const savingsEl = document.createElement("div");
                  savingsEl.className = "token-savings";
                  savingsEl.textContent = `${savings}% fewer words than CoT`;
                  wordCountBadge.appendChild(savingsEl);
                }
              }
            }
            
            messageDiv.appendChild(wordCountBadge);
          }

          chatMessagesDiv.appendChild(messageDiv);
        });
        chatMessagesDiv.scrollTop = chatMessagesDiv.scrollHeight;
      }
      addCodeCopyButtons();
    }

    function addMessageToCurrentThread(content, sender, isPlaceholder = false) {
      const thread = threads.find(t => t.id === currentThreadId);
      if (thread) {
        // Process bot messages to separate thinking from answer
        let thinking = null;
        let answer = null;
        let thinkingWordCount = 0;
        let answerWordCount = 0;
        let totalWordCount = 0;
        
        if (sender === "bot" && !isPlaceholder) {
          const processed = processBotMessage(content, REASONING_METHOD);
          thinking = processed.thinking;
          answer = processed.answer;
          thinkingWordCount = processed.thinkingWordCount || 0;
          answerWordCount = processed.answerWordCount || 0;
          totalWordCount = thinkingWordCount + answerWordCount;
        }
        
        thread.messages.push({
          content,
          sender,
          isPlaceholder,
          timestamp: new Date(),
          wordCount: sender === "bot" && !isPlaceholder ? totalWordCount : undefined,
          reasoningMethod: sender === "bot" && !isPlaceholder ? 
            (REASONING_METHOD === "cod" ? `${REASONING_METHOD.toUpperCase()}-${COD_WORD_LIMIT}` : REASONING_METHOD.toUpperCase()) : 
            undefined,
          thinking,
          answer,
          thinkingWordCount: sender === "bot" && !isPlaceholder ? thinkingWordCount : undefined,
          answerWordCount: sender === "bot" && !isPlaceholder ? answerWordCount : undefined,
          // NEW: Add complexity info for debugging
          complexityInfo: sender === "user" ? PROBLEM_COMPLEXITY : undefined
        });
        renderCurrentThreadMessages();
      }
    }

    /***********************
     * Build Messages Array for Chat Completions
     ***********************/
    function buildMessagesForChat(wordCountRequest = null) {
      const thread = threads.find(t => t.id === currentThreadId);
      if (!thread) return [];
      
      const messages = [];
      
      let systemPrompt = "";
      
      // Use enhanced reasoning for complex problems if enabled
      let shouldUseEnhancedPrompt = false;
      let problemType = "";
      
      // Determine if this is a complex problem that needs enhanced reasoning
      if (ENHANCED_REASONING_ENABLED && REASONING_ENHANCEMENT === "adaptive") {
        if (PROBLEM_COMPLEXITY.complexity === "complex") {
          shouldUseEnhancedPrompt = true;
          problemType = "complex";
          console.log("Using enhanced prompts for complex problem detected");
        } 
        else if (PROBLEM_COMPLEXITY.hasMath && (PROBLEM_COMPLEXITY.multiStep || PROBLEM_COMPLEXITY.hasLogic)) {
          // Even if not fully "complex", if it has math AND either multi-step reasoning or logic,
          // it's still worth enhancing the prompt
          shouldUseEnhancedPrompt = true;
          problemType = "mathematical";
          console.log("Using enhanced prompts for mathematical problem detected");
        }
      }
      
      // If we have a reasoning method other than standard, add the system prompt
      if (REASONING_METHOD !== "standard") {
        // Determine which prompt to use based on complexity and settings
        if (shouldUseEnhancedPrompt) {
          if (REASONING_METHOD === "cot") {
            systemPrompt = ENHANCED_PROMPTS.cot;
          } else if (REASONING_METHOD === "cod") {
            // Use the appropriate CoD prompt based on word limit
            if (COD_WORD_LIMIT === 5) {
              systemPrompt = ENHANCED_PROMPTS.cod5;
            } else if (COD_WORD_LIMIT === 10) {
              systemPrompt = ENHANCED_PROMPTS.cod10;
            } else if (COD_WORD_LIMIT === 15) {
              systemPrompt = ENHANCED_PROMPTS.cod15;
            } else if (COD_WORD_LIMIT === 17) {
              systemPrompt = ENHANCED_PROMPTS.cod17;
            } else if (COD_WORD_LIMIT === 20) {
              systemPrompt = ENHANCED_PROMPTS.cod20;
            } else {
              // Fallback to standard prompt but update word limit
              systemPrompt = PROMPTS[REASONING_METHOD].replace(/\(\d+ words maximum per step\)/, `(${COD_WORD_LIMIT} words maximum per step)`);
            }
          }
        } else {
          // Use the selected reasoning method prompt
          systemPrompt = PROMPTS[REASONING_METHOD];
          
          // If it's COD, update the word limit
          if (REASONING_METHOD === "cod") {
            // First update the word limit
            systemPrompt = systemPrompt.replace(/\(\d+ words maximum per step\)/, `(${COD_WORD_LIMIT} words maximum per step)`);
            
            // If this is a problem that needs many steps, add instructions to use more steps
            if (PROBLEM_COMPLEXITY.estimatedSteps > 5) {
              // Insert guidance about using sufficient steps after the first paragraph
              const firstParagraphEnd = systemPrompt.indexOf("\n\n");
              if (firstParagraphEnd !== -1) {
                const beforeInsert = systemPrompt.substring(0, firstParagraphEnd);
                const afterInsert = systemPrompt.substring(firstParagraphEnd);
                
                const insertText = `\n\nIMPORTANT: This problem may require ${PROBLEM_COMPLEXITY.estimatedSteps}+ reasoning steps. Use as many steps as needed to fully solve the problem - it's better to break complex reasoning into more simple steps than to skip important details.`;
                
                systemPrompt = beforeInsert + insertText + afterInsert;
              }
            }
          }
        }
        
        // If word count limit was requested, modify the prompt to clarify it applies to final answer only
        if (wordCountRequest && wordCountRequest > 0) {
          if (REASONING_METHOD === "cod") {
            // For CoD, add the instruction right before the examples section
            const examplesIndex = systemPrompt.indexOf("Examples:");
            if (examplesIndex !== -1) {
              const beforeExamples = systemPrompt.substring(0, examplesIndex);
              const afterExamples = systemPrompt.substring(examplesIndex);
              
              systemPrompt = `${beforeExamples}\nIMPORTANT: Your final answer after the #### separator should be ${wordCountRequest} words maximum. The word limit applies ONLY to your final answer, not your thinking steps.\n\n${afterExamples}`;
            } else {
              systemPrompt += `\n\nIMPORTANT: Your final answer after the #### separator should be ${wordCountRequest} words maximum. The word limit applies ONLY to your final answer, not your thinking steps.`;
            }
          } else if (REASONING_METHOD === "cot") {
            // For CoT, add to the end of the prompt
            systemPrompt += `\n\nIMPORTANT: Your final answer should be ${wordCountRequest} words maximum. This word limit applies ONLY to your final answer, not your thinking process.`;
          }
        }
        
        let reasoningInfo = `${REASONING_METHOD.toUpperCase()}`;
        if (REASONING_METHOD === "cod") {
          reasoningInfo += `-${COD_WORD_LIMIT}`;
        }
        
        if (shouldUseEnhancedPrompt) {
          reasoningInfo += " (Enhanced for complex problem)";
        }
        
        console.log(`Using ${reasoningInfo} prompt`);
        
        if (wordCountRequest) {
          console.log(`Added instruction for ${wordCountRequest} word limit on final answer only`);
        }
        
        messages.push({
          role: "system",
          content: systemPrompt
        });
      } else {
        console.log("Using standard reasoning (no special prompt)");
        
        // If word count limit was requested, add a system message for it
        if (wordCountRequest && wordCountRequest > 0) {
          messages.push({
            role: "system",
            content: `Please limit your response to ${wordCountRequest} words maximum.`
          });
          console.log(`Added instruction for ${wordCountRequest} word limit`);
        }
      }
      
      // Add all user and assistant messages
      thread.messages
        .filter(msg => !msg.isPlaceholder)
        .forEach(msg => {
          messages.push({
            role: msg.sender === "user" ? "user" : "assistant",
            content: msg.content
          });
        });
      
      return messages;
    }

    /***********************
     * Message Sending
     ***********************/
    async function sendMessage(message) {
      // NEW: Analyze problem complexity if enhanced reasoning is enabled
      if (ENHANCED_REASONING_ENABLED && REASONING_ENHANCEMENT === "adaptive") {
        analyzeProblemComplexity(message);
      }
      
      addMessageToCurrentThread(message, "user");

      if (!MODEL_NAME) {
        const errorMsg = "Error: Please set the Model Name in the Settings.";
        addMessageToCurrentThread(errorMsg, "bot");
        console.error(errorMsg);
        return;
      }

      // Parse message for word count requirements
      const wordCountRequest = parseWordCountRequest(message);
      
      addMessageToCurrentThread("Bot is typing...", "bot", true);
      const thread = threads.find(t => t.id === currentThreadId);
      const placeholderIndex = thread.messages.length - 1;

      // Build messages array with current settings and word count request
      const messagesForApi = buildMessagesForChat(wordCountRequest);

      // Create payload
      const payload = {
        model: MODEL_NAME,
        max_tokens: MAX_TOKENS,
        top_p: TOP_P,
        top_k: TOP_K,
        presence_penalty: PRESENCE_PENALTY,
        frequency_penalty: FREQUENCY_PENALTY,
        temperature: TEMPERATURE,
        messages: messagesForApi
      };
      
      console.log(`Sending request with ${REASONING_METHOD} reasoning ${REASONING_METHOD === "cod" ? `(word limit: ${COD_WORD_LIMIT})` : ""}`);
      if (wordCountRequest) {
        console.log(`Final answer word limit requested: ${wordCountRequest} words`);
      }
      console.log(`Parameters: temp=${TEMPERATURE}, top_p=${TOP_P}, top_k=${TOP_K}`);

      try {
        // Add timestamp to URL to prevent caching
        const timestamp = new Date().getTime();
        const cacheBuster = `?t=${timestamp}`;
        
        const response = await fetch(`${API_PROXY_URL}${cacheBuster}`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify(payload)
        });
        
        if (!response.ok) {
          throw new Error(`HTTP error! Status: ${response.status}`);
        }
        
        const data = await response.json();
        const botReply = data.choices &&
                         data.choices[0] &&
                         data.choices[0].message &&
                         data.choices[0].message.content;
        if (botReply) {
          const trimmedReply = botReply.trim();
          
          // Create response metadata
          let reasoningInfo = REASONING_METHOD.toUpperCase();
          if (REASONING_METHOD === "cod") {
            reasoningInfo += `-${COD_WORD_LIMIT}`;
          }
          
          // Add enhanced reasoning info if used
          if (ENHANCED_REASONING_ENABLED && 
              REASONING_ENHANCEMENT === "adaptive" && 
              PROBLEM_COMPLEXITY.complexity === "complex") {
            reasoningInfo += "-ENHANCED";
          }
          
          // Process bot message to separate thinking and answer parts
          const processed = processBotMessage(trimmedReply, REASONING_METHOD);
          
          thread.messages[placeholderIndex] = {
            content: trimmedReply,
            sender: "bot",
            isPlaceholder: false,
            timestamp: new Date(),
            wordCount: (processed.thinkingWordCount || 0) + (processed.answerWordCount || 0),
            reasoningMethod: reasoningInfo,
            thinking: processed.thinking,
            answer: processed.answer,
            thinkingWordCount: processed.thinkingWordCount || 0,
            answerWordCount: processed.answerWordCount || 0
          };
        } else {
          thread.messages[placeholderIndex] = {
            content: "No valid response received. Check model name and API key.",
            sender: "bot",
            isPlaceholder: false,
            timestamp: new Date(),
            wordCount: 0,
            reasoningMethod: REASONING_METHOD.toUpperCase(),
            thinking: null,
            answer: null,
            thinkingWordCount: 0,
            answerWordCount: 0
          };
        }
      } catch (error) {
        console.error("Error communicating with API:", error);
        
        // Provide more detailed error message
        let errorMessage = "Error communicating with API: " + error.message;
        
        // Add suggestions based on error type
        if (error.message.includes("Failed to fetch")) {
          errorMessage += "\n\nPossible solutions:\n1. Make sure your API key is set correctly in Netlify\n2. Check that your model name is valid\n3. Verify your internet connection";
        }
        
        thread.messages[placeholderIndex] = {
          content: errorMessage,
          sender: "bot",
          isPlaceholder: false,
          timestamp: new Date(),
          wordCount: 0,
          reasoningMethod: REASONING_METHOD.toUpperCase(),
          thinking: null,
          answer: null,
          thinkingWordCount: 0,
          answerWordCount: 0
        };
      }
      renderCurrentThreadMessages();
    }

    /***********************
     * Code Copy Feature
     ***********************/
    function addCodeCopyButtons() {
      const codeBlocks = document.querySelectorAll('pre code');
      codeBlocks.forEach(code => {
        if (code.parentElement.classList.contains('code-block-container')) {
          return;
        }
        const pre = code.parentElement;
        const container = document.createElement('div');
        container.className = 'code-block-container';
        pre.parentNode.insertBefore(container, pre);
        container.appendChild(pre);

        const copyBtn = document.createElement('button');
        copyBtn.className = 'copy-btn';
        copyBtn.textContent = 'Copy';
        copyBtn.addEventListener('click', () => {
          navigator.clipboard.writeText(code.innerText);
          copyBtn.textContent = 'Copied!';
          setTimeout(() => {
            copyBtn.textContent = 'Copy';
          }, 1500);
        });
        container.appendChild(copyBtn);
      });
    }

    /***********************
     * Notification System
     ***********************/
    function showNotification(message, duration = 3000) {
      const notification = document.getElementById("statusNotification");
      notification.textContent = message;
      notification.classList.add("show");
      
      setTimeout(() => {
        notification.classList.remove("show");
      }, duration);
    }

    /***********************
     * Feedback Form
     ***********************/
    function initFeedbackForm() {
      // Get references to elements
      const openBtn = document.getElementById('openFeedbackBtn');
      const modal = document.getElementById('feedbackModal');
      const closeBtn = document.getElementById('closeFeedbackModal');
      const modelInput = document.getElementById('feedbackModel');
      const reasoningInput = document.getElementById('feedbackReasoning');
      
      // Set up event listeners
      if (openBtn) {
        openBtn.addEventListener('click', () => {
          // Update hidden fields with current model info
          if (modelInput) modelInput.value = MODEL_NAME_DISPLAY || 'Not set';
          if (reasoningInput) {
            let reasoningMethod = REASONING_METHOD.toUpperCase();
            if (REASONING_METHOD === 'cod') {
              reasoningMethod += `-${COD_WORD_LIMIT}`;
            }
            reasoningInput.value = reasoningMethod;
          }
          
          // Show the modal
          if (modal) modal.style.display = 'block';
        });
      }
      
      if (closeBtn) {
        closeBtn.addEventListener('click', () => {
          if (modal) modal.style.display = 'none';
        });
      }
      
      // Close modal when clicking outside
      window.addEventListener('click', (event) => {
        if (event.target === modal) {
          modal.style.display = 'none';
        }
      });
      
      // Show success message after form submission
      const form = document.querySelector('form[name="feedback"]');
      if (form) {
        form.addEventListener('submit', () => {
          setTimeout(() => {
            showNotification('Thank you for your feedback!');
            if (modal) modal.style.display = 'none';
          }, 500);
        });
      }
    }

    /***********************
     * Settings Management
     ***********************/
    
    // Tab handling
    function setupTabNavigation() {
      try {
        console.log("Setting up tab navigation");
        
        // Get all tab buttons and tab contents
        const tabButtons = document.querySelectorAll('.tab-btn');
        const tabContents = document.querySelectorAll('.tab-content');
        
        if (tabButtons.length === 0) {
          console.warn("No tab buttons found");
        }
        
        // Add click event listeners to tab buttons
        tabButtons.forEach(button => {
          button.addEventListener('click', () => {
            try {
              // Remove active class from all buttons and contents
              tabButtons.forEach(btn => btn.classList.remove('active'));
              tabContents.forEach(content => content.classList.remove('active'));
              
              // Add active class to clicked button
              button.classList.add('active');
              
              // Show corresponding tab content
              const tabId = button.getAttribute('data-tab');
              const tabContent = document.getElementById(tabId);
              if (tabContent) {
                tabContent.classList.add('active');
              } else {
                console.warn(`Tab content with id "${tabId}" not found`);
              }
            } catch (err) {
              console.error("Error handling tab click:", err);
            }
          });
        });
      } catch (err) {
        console.error("Error in setupTabNavigation:", err);
      }
    }
    
    // Custom model handling
    function setupModelInput() {
      const modelInput = document.getElementById('modelName');
      const setModelBtn = document.getElementById('setModelBtn');
      
      setModelBtn.addEventListener('click', () => {
        const modelName = modelInput.value.trim();
        if (modelName) {
          MODEL_NAME = modelName;
          MODEL_NAME_DISPLAY = getModelDisplayName(modelName);
          updateCurrentModelDisplay();
          showNotification('Model set: ' + MODEL_NAME_DISPLAY);
        } else {
          showNotification('Please enter a valid model name');
        }
      });
    }
    
    // Improved Chain of Draft word limit options UI
    function updateCoDOptionsUI() {
      const codOptions = document.getElementById('codOptions');
      if (!codOptions) return;
      
      codOptions.innerHTML = `
        <div class="option-label">Word limit per step:</div>
        <div class="cod-word-limit-options">
          <div class="cod-word-limit-option ${COD_WORD_LIMIT === 5 ? 'selected' : ''}" data-value="5">
            <span class="cod-word-limit-value">5 words</span>
            <span class="cod-word-limit-desc">Original paper recommendation</span>
          </div>
          <div class="cod-word-limit-option ${COD_WORD_LIMIT === 10 ? 'selected' : ''}" data-value="10">
            <span class="cod-word-limit-value">10 words</span>
            <span class="cod-word-limit-desc">Balanced brevity and clarity</span>
          </div>
          <div class="cod-word-limit-option ${COD_WORD_LIMIT === 15 ? 'selected' : ''}" data-value="15">
            <span class="cod-word-limit-value">15 words</span>
            <span class="cod-word-limit-desc">More descriptive steps</span>
          </div>
          <div class="cod-word-limit-option ${COD_WORD_LIMIT === 17 ? 'selected' : ''}" data-value="17">
            <span class="cod-word-limit-value">17 words</span>
            <span class="cod-word-limit-desc">Better for complex reasoning</span>
          </div>
          <div class="cod-word-limit-option ${COD_WORD_LIMIT === 20 ? 'selected' : ''}" data-value="20">
            <span class="cod-word-limit-value">20 words</span>
            <span class="cod-word-limit-desc">Detailed steps for math & logic</span>
          </div>
        </div>
        
        <div class="cod-examples">
          <div class="cod-examples-header">Chain of Draft Example</div>
          <div class="cod-example-item">
            <div class="cod-example-question">Q: If a fabric store received 45 yards of cotton and used 2/9 of it, how many yards remain?</div>
            <div class="cod-example-answer">A: Total: 45 yards. Used: 2/9 × 45 = 10 yards. Remaining: 45 - 10 = 35 yards. #### 35 yards</div>
          </div>
        </div>
      `;
      
      // Add event listeners to the word limit options
      const wordLimitOptions = document.querySelectorAll('.cod-word-limit-option');
      wordLimitOptions.forEach(option => {
        option.addEventListener('click', () => {
          // Update selected state
          wordLimitOptions.forEach(opt => opt.classList.remove('selected'));
          option.classList.add('selected');
          
          // Update word limit value
          COD_WORD_LIMIT = parseInt(option.getAttribute('data-value'));
          
          // Update the prompt
          updateCoDPrompt();
          
          // Update display
          updateCurrentModelDisplay();
        });
      });
    }
    
    // Improved function to update the CoD prompt when word limit changes
    function updateCoDPrompt() {
      // Update the prompt to reflect new word limit
      const basePrompt = `Think step by step, but produce only minimal notes for each step (${COD_WORD_LIMIT} words maximum per step). Use mathematical notation where possible. Keep only essential information needed to solve the problem. Focus on key calculations and intermediate results without narrative explanation.
  
Separate your steps with periods. Write your final answer after the #### separator.`;
      
      // Keep the examples part of the prompt
      const examplesStart = PROMPTS.cod.indexOf('Examples:');
      if (examplesStart !== -1) {
        PROMPTS.cod = basePrompt + '\n\n' + PROMPTS.cod.substring(examplesStart);
      } else {
        PROMPTS.cod = basePrompt;
      }
      
      console.log(`Updated CoD prompt with word limit: ${COD_WORD_LIMIT}`);
    }
    
    // Setup Enhanced Reasoning options
    function setupEnhancedReasoningOptions() {
      const enhancedToggle = document.getElementById('enhancedReasoningToggle');
      const optionsContainer = document.getElementById('enhancedReasoningOptions');
      const adaptiveRadio = document.getElementById('adaptiveReasoning');
      const standardRadio = document.getElementById('standardReasoning');
      
      // Initialize state
      if (enhancedToggle) {
        enhancedToggle.checked = ENHANCED_REASONING_ENABLED;
        if (optionsContainer) {
          optionsContainer.style.display = ENHANCED_REASONING_ENABLED ? 'block' : 'none';
        }
      }
      
      if (adaptiveRadio && standardRadio) {
        if (REASONING_ENHANCEMENT === 'adaptive') {
          adaptiveRadio.checked = true;
        } else {
          standardRadio.checked = true;
        }
      }
      
      // Add event listeners
      if (enhancedToggle) {
        enhancedToggle.addEventListener('change', () => {
          ENHANCED_REASONING_ENABLED = enhancedToggle.checked;
          if (optionsContainer) {
            optionsContainer.style.display = ENHANCED_REASONING_ENABLED ? 'block' : 'none';
          }
          updateCurrentModelDisplay();
        });
      }
      
      if (adaptiveRadio) {
        adaptiveRadio.addEventListener('change', () => {
          if (adaptiveRadio.checked) {
            REASONING_ENHANCEMENT = 'adaptive';
            updateCurrentModelDisplay();
          }
        });
      }
      
      if (standardRadio) {
        standardRadio.addEventListener('change', () => {
          if (standardRadio.checked) {
            REASONING_ENHANCEMENT = 'standard';
            updateCurrentModelDisplay();
          }
        });
      }
    }
    
    // Setup COD options display
    function setupCODOptions() {
      const reasoningRadios = document.getElementsByName('reasoningMethod');
      const codOptions = document.getElementById('codOptions');
      
      // Initial state
      if (REASONING_METHOD === 'cod') {
        codOptions.style.display = 'block';
        updateCoDOptionsUI();
      } else {
        codOptions.style.display = 'none';
      }
      
      // Update when reasoning method changes
      reasoningRadios.forEach(radio => {
        radio.addEventListener('change', () => {
          if (radio.value === 'cod' && radio.checked) {
            codOptions.style.display = 'block';
            updateCoDOptionsUI();
          } else {
            codOptions.style.display = 'none';
          }
        });
      });
    }
    
    // Settings slider handling
    function setupSliders() {
      // Connect all sliders to their value displays
      document.querySelectorAll('input[type="range"]').forEach(slider => {
        const valueDisplay = document.getElementById(`${slider.id}Value`);
        if (valueDisplay) {
          slider.addEventListener('input', () => {
            valueDisplay.textContent = slider.value;
          });
        }
      });
    }
    
    function openSettingsModal() {
      try {
        console.log("Opening settings modal");
        
        // Initialize settings UI
        const modelNameInput = document.getElementById("modelName");
        if (modelNameInput) modelNameInput.value = MODEL_NAME;
        
        // Set reasoning method radio buttons
        const reasoningRadio = document.getElementById(`${REASONING_METHOD}Reasoning`);
        if (reasoningRadio) reasoningRadio.checked = true;
        
        // Set enhanced reasoning options
        const enhancedToggle = document.getElementById('enhancedReasoningToggle');
        if (enhancedToggle) enhancedToggle.checked = ENHANCED_REASONING_ENABLED;
        
        const enhancedOptionsContainer = document.getElementById('enhancedReasoningOptions');
        if (enhancedOptionsContainer) {
          enhancedOptionsContainer.style.display = ENHANCED_REASONING_ENABLED ? 'block' : 'none';
        }
        
        const adaptiveRadio = document.getElementById('adaptiveReasoning');
        const standardRadio = document.getElementById('standardReasoning');
        
        if (adaptiveRadio && standardRadio) {
          if (REASONING_ENHANCEMENT === 'adaptive') {
            adaptiveRadio.checked = true;
          } else {
            standardRadio.checked = true;
          }
        }
        
        // Set parameter sliders
        setSliderAndValue("temp", TEMPERATURE);
        setSliderAndValue("topP", TOP_P);
        setSliderAndValue("topK", TOP_K);
        setSliderAndValue("maxTokens", MAX_TOKENS);
        setSliderAndValue("presencePenalty", PRESENCE_PENALTY);
        setSliderAndValue("frequencyPenalty", FREQUENCY_PENALTY);
        
        // Show modal
        const modal = document.getElementById("settingsModal");
        if (modal) modal.style.display = "block";
        
        console.log("Settings modal opened successfully");
      } catch (err) {
        console.error("Error in openSettingsModal:", err);
      }
    }
    
    function setSliderAndValue(id, value) {
      const slider = document.getElementById(id);
      const valueDisplay = document.getElementById(`${id}Value`);
      
      if (slider) slider.value = value;
      if (valueDisplay) valueDisplay.textContent = value;
    }

    function closeSettingsModal() {
      document.getElementById("settingsModal").style.display = "none";
    }

    function saveSettings() {
      try {
        console.log("Saving settings...");
        
        // Save previous settings for comparison
        const prevMethod = REASONING_METHOD;
        const prevWordLimit = COD_WORD_LIMIT;
        const prevEnhanced = ENHANCED_REASONING_ENABLED;
        const prevEnhancementType = REASONING_ENHANCEMENT;
        
        // Save model name
        const modelNameEl = document.getElementById("modelName");
        if (modelNameEl) {
          MODEL_NAME = modelNameEl.value.trim();
          MODEL_NAME_DISPLAY = getModelDisplayName(MODEL_NAME);
        }
        
        // Save reasoning method
        const reasoningRadios = document.getElementsByName("reasoningMethod");
        for (const radio of reasoningRadios) {
          if (radio.checked) {
            REASONING_METHOD = radio.value;
            break;
          }
        }
        
        // Save COD word limit if applicable
        if (REASONING_METHOD === "cod") {
          // Get the selected CoD word limit option
          const selectedOption = document.querySelector('.cod-word-limit-option.selected');
          if (selectedOption) {
            COD_WORD_LIMIT = parseInt(selectedOption.getAttribute('data-value'));
          }
        }
        
        // Save enhanced reasoning settings
        const enhancedToggle = document.getElementById('enhancedReasoningToggle');
        if (enhancedToggle) {
          ENHANCED_REASONING_ENABLED = enhancedToggle.checked;
        }
        
        const adaptiveRadio = document.getElementById('adaptiveReasoning');
        const standardRadio = document.getElementById('standardReasoning');
        
        if (adaptiveRadio && standardRadio) {
          if (adaptiveRadio.checked) {
            REASONING_ENHANCEMENT = 'adaptive';
          } else if (standardRadio.checked) {
            REASONING_ENHANCEMENT = 'standard';
          }
        }
        
        // Save generation parameters safely
        const getNumericValue = (id, defaultVal, parseFunc) => {
          const el = document.getElementById(id);
          return el ? parseFunc(el.value) : defaultVal;
        };
        
        TEMPERATURE = getNumericValue("temp", 0.5, parseFloat);
        TOP_P = getNumericValue("topP", 0.9, parseFloat);
        TOP_K = getNumericValue("topK", 55, parseInt);
        MAX_TOKENS = getNumericValue("maxTokens", 1112, parseInt);
        PRESENCE_PENALTY = getNumericValue("presencePenalty", 0, parseFloat);
        FREQUENCY_PENALTY = getNumericValue("frequencyPenalty", 0.4, parseFloat);
        
        // Update model display
        updateCurrentModelDisplay();
        
        // Save settings to localStorage
        try {
          localStorage.setItem("modelName", MODEL_NAME);
          localStorage.setItem("reasoningMethod", REASONING_METHOD);
          localStorage.setItem("codWordLimit", COD_WORD_LIMIT.toString());
          localStorage.setItem("enhancedReasoningEnabled", ENHANCED_REASONING_ENABLED.toString());
          localStorage.setItem("reasoningEnhancement", REASONING_ENHANCEMENT);
          localStorage.setItem("temperature", TEMPERATURE.toString());
          localStorage.setItem("topP", TOP_P.toString());
          localStorage.setItem("topK", TOP_K.toString());
          localStorage.setItem("maxTokens", MAX_TOKENS.toString());
          localStorage.setItem("presencePenalty", PRESENCE_PENALTY.toString());
          localStorage.setItem("frequencyPenalty", FREQUENCY_PENALTY.toString());
          
          // Save custom prompts
          localStorage.setItem("customPrompts", JSON.stringify(PROMPTS));
          localStorage.setItem("enhancedPrompts", JSON.stringify(ENHANCED_PROMPTS));
          console.log("Settings saved to localStorage");
        } catch (storageErr) {
          console.error("Error saving to localStorage:", storageErr);
        }
        
        closeSettingsModal();
        
        // Check if reasoning method or COD word limit changed and notify user
        if (prevMethod !== REASONING_METHOD || 
            (REASONING_METHOD === "cod" && prevMethod === "cod" && prevWordLimit !== COD_WORD_LIMIT) ||
            prevEnhanced !== ENHANCED_REASONING_ENABLED ||
            prevEnhancementType !== REASONING_ENHANCEMENT) {
          showNotification("Settings saved - reasoning method changed. Next message will use new settings.");
        } else {
          showNotification("Settings saved");
        }
      } catch (err) {
        console.error("Error in saveSettings:", err);
        showNotification("Error saving settings");
      }
    }

    /***********************
     * Event Listeners
     ***********************/
    function initEventListeners() {
      try {
        console.log("Initializing event listeners");
        
        // Helper function to safely add event listeners
        const addListener = (id, event, handler) => {
          const element = document.getElementById(id);
          if (element) {
            element.addEventListener(event, handler);
          } else {
            console.warn(`Element with id "${id}" not found for event listener`);
          }
        };
        
        // Settings buttons
        addListener("openSettings", "click", openSettingsModal);
        addListener("closeSettings", "click", closeSettingsModal);
        addListener("closeModalX", "click", closeSettingsModal);
        addListener("saveSettings", "click", saveSettings);
        
        // Thread management
        addListener("newThreadBtn", "click", createNewThread);
        addListener("deleteThreadBtn", "click", deleteCurrentThread);
        addListener("downloadTxtBtn", "click", downloadCurrentThreadAsTxt);
        addListener("downloadPdfBtn", "click", downloadCurrentThreadAsPdf);
        
        // Message sending
        addListener("sendBtn", "click", () => {
          const userInput = document.getElementById("userInput");
          if (userInput) {
            const message = userInput.value.trim();
            if (message) {
              sendMessage(message);
              userInput.value = "";
            }
          }
        });
        
        const userInput = document.getElementById("userInput");
        if (userInput) {
          userInput.addEventListener("keydown", (event) => {
            if (event.key === "Enter" && !event.shiftKey) {
              event.preventDefault();
              const sendBtn = document.getElementById("sendBtn");
              if (sendBtn) sendBtn.click();
            }
          });
        }
        
        // Close modal when clicking outside
        window.addEventListener("click", (event) => {
          const modal = document.getElementById("settingsModal");
          if (modal && event.target === modal) {
            closeSettingsModal();
          }
        });
        
        // Set up settings UI functionality
        setTimeout(() => {
          try {
            setupTabNavigation();
            setupModelInput();
            setupCODOptions();
            setupEnhancedReasoningOptions();
            setupSliders();
            console.log("UI functionality setup complete");
          } catch (err) {
            console.error("Error setting up UI functionality:", err);
          }
        }, 100);
      } catch (err) {
        console.error("Error initializing event listeners:", err);
      }
    }

    /***********************
     * Initialization
     ***********************/
    function loadPersistedSettings() {
      try {
        MODEL_NAME = localStorage.getItem("modelName") || "";
        MODEL_NAME_DISPLAY = getModelDisplayName(MODEL_NAME);
        
        REASONING_METHOD = localStorage.getItem("reasoningMethod") || "cod";
        
        const codWordLimit = localStorage.getItem("codWordLimit");
        if (codWordLimit) COD_WORD_LIMIT = parseInt(codWordLimit);
        
        // Load enhanced reasoning settings
        const enhancedEnabled = localStorage.getItem("enhancedReasoningEnabled");
        if (enhancedEnabled !== null) {
          ENHANCED_REASONING_ENABLED = enhancedEnabled === "true";
        }
        
        const enhancementType = localStorage.getItem("reasoningEnhancement");
        if (enhancementType) {
          REASONING_ENHANCEMENT = enhancementType;
        }
        
        // Load custom prompts if available
        const storedPrompts = localStorage.getItem("customPrompts");
        if (storedPrompts) {
          const parsedPrompts = JSON.parse(storedPrompts);
          // Merge with default prompts to ensure all properties exist
          PROMPTS = { ...PROMPTS, ...parsedPrompts };
        }
        
        // Load enhanced prompts if available
        const storedEnhancedPrompts = localStorage.getItem("enhancedPrompts");
        if (storedEnhancedPrompts) {
          const parsedEnhancedPrompts = JSON.parse(storedEnhancedPrompts);
          // Merge with default prompts to ensure all properties exist
          ENHANCED_PROMPTS = { ...ENHANCED_PROMPTS, ...parsedEnhancedPrompts };
        }
        
        const temp = localStorage.getItem("temperature");
        if (temp) TEMPERATURE = parseFloat(temp);
        
        const topP = localStorage.getItem("topP");
        if (topP) TOP_P = parseFloat(topP);
        
        const topK = localStorage.getItem("topK");
        if (topK) TOP_K = parseInt(topK);
        
        const maxTokens = localStorage.getItem("maxTokens");
        if (maxTokens) MAX_TOKENS = parseInt(maxTokens);
        
        const presencePenalty = localStorage.getItem("presencePenalty");
        if (presencePenalty) PRESENCE_PENALTY = parseFloat(presencePenalty);
        
        const frequencyPenalty = localStorage.getItem("frequencyPenalty");
        if (frequencyPenalty) FREQUENCY_PENALTY = parseFloat(frequencyPenalty);
      } catch (err) {
        console.error("Error loading settings:", err);
      }
    }
/***********************
 * Image Handling
 ***********************/
 let uploadedImages = [];

function setupImageUpload() {
  const uploadBtn = document.getElementById("imageUploadBtn");
  const uploadInput = document.getElementById("imageUpload");
  
  if (uploadBtn && uploadInput) {
    uploadBtn.addEventListener("click", () => {
      uploadInput.click();
    });
    
    uploadInput.addEventListener("change", handleImageUpload);
  }
}

function handleImageUpload(event) {
  const files = event.target.files;
  if (!files || files.length === 0) return;
  
  // Create preview container if it doesn't exist
  let previewContainer = document.querySelector(".image-preview");
  if (!previewContainer) {
    previewContainer = document.createElement("div");
    previewContainer.className = "image-preview";
    const chatInput = document.querySelector(".chat-input");
    chatInput.parentNode.insertBefore(previewContainer, chatInput);
  }
  
  // Process each file
  for (const file of files) {
    if (!file.type.startsWith("image/")) continue;
    
    const reader = new FileReader();
    reader.onload = function(e) {
      const imageData = e.target.result;
      const imageId = Date.now() + "_" + uploadedImages.length;
      
      // Add to uploaded images array
      uploadedImages.push({
        id: imageId,
        data: imageData,
        name: file.name
      });
      
      // Create preview element
      const previewItem = document.createElement("div");
      previewItem.className = "image-preview-item";
      previewItem.dataset.imageId = imageId;
      
      const img = document.createElement("img");
      img.src = imageData;
      previewItem.appendChild(img);
      
      const removeBtn = document.createElement("button");
      removeBtn.className = "remove-image";
      removeBtn.innerHTML = "×";
      removeBtn.addEventListener("click", () => removeImage(imageId));
      previewItem.appendChild(removeBtn);
      
      previewContainer.appendChild(previewItem);
    };
    reader.readAsDataURL(file);
  }
  
  // Reset file input
  event.target.value = "";
}

function removeImage(imageId) {
  // Remove from array
  uploadedImages = uploadedImages.filter(img => img.id !== imageId);
  
  // Remove preview
  const previewItem = document.querySelector(`.image-preview-item[data-image-id="${imageId}"]`);
  if (previewItem) {
    previewItem.remove();
  }
  
  // Remove container if empty
  const previewContainer = document.querySelector(".image-preview");
  if (previewContainer && previewContainer.children.length === 0) {
    previewContainer.remove();
  }
}

// Modify the sendMessage function to include images
function sendMessage(message) {
  // NEW: Include images in the message if any
  let messageWithImages = message;
  let imagesToSend = [...uploadedImages]; // Copy the array
  
  if (imagesToSend.length > 0) {
    // Add images to user message in UI
    const imgHtml = imagesToSend.map(img => 
      `<img src="${img.data}" alt="Uploaded image" class="image-in-message">`
    ).join('');
    
    addMessageToCurrentThread(message + imgHtml, "user");
    
    // Format message with image descriptions for the API
    let imageDescriptions = imagesToSend.map((img, index) => 
      `[Image ${index + 1}: ${img.name}]`
    ).join('\n');
    
    messageWithImages = `${message}\n\n${imageDescriptions}`;
  } else {
    addMessageToCurrentThread(message, "user");
  }
  
  // Rest of the existing function
  if (!MODEL_NAME) {
    const errorMsg = "Error: Please set the Model Name in the Settings.";
    addMessageToCurrentThread(errorMsg, "bot");
    console.error(errorMsg);
    return;
  }
  
  // ... [rest of the existing function] ...
  
  // NEW: Enhance the payload to include images
  const payload = {
    model: MODEL_NAME,
    max_tokens: MAX_TOKENS,
    top_p: TOP_P,
    top_k: TOP_K,
    presence_penalty: PRESENCE_PENALTY,
    frequency_penalty: FREQUENCY_PENALTY,
    temperature: TEMPERATURE,
    messages: buildMessagesForChat(wordCountRequest, imagesToSend)
  };
  
  // Clear uploaded images after sending
  uploadedImages = [];
  const previewContainer = document.querySelector(".image-preview");
  if (previewContainer) {
    previewContainer.remove();
  }
  
  // ... [continue with API call and handling response] ...
}

// Modify buildMessagesForChat to include images
function buildMessagesForChat(wordCountRequest = null, imagesToSend = []) {
  const thread = threads.find(t => t.id === currentThreadId);
  if (!thread) return [];
  
  const messages = [];
  
  // ... [existing system prompt code] ...
  
  // Add all user and assistant messages
  thread.messages
    .filter(msg => !msg.isPlaceholder)
    .forEach((msg, index) => {
      // If this is the last user message and we have images to send
      if (msg.sender === "user" && 
          index === thread.messages.length - 1 && 
          imagesToSend.length > 0) {
        
        // Create a message with images in format required by Fireworks API
        const userMessageWithImages = {
          role: "user",
          content: [
            { type: "text", text: msg.content.replace(/<img.*?>/g, '') }
          ]
        };
        
        // Add image content items
        imagesToSend.forEach(img => {
          userMessageWithImages.content.push({
            type: "image_url",
            image_url: { url: img.data }
          });
        });
        
        messages.push(userMessageWithImages);
      } else {
        // Standard message
        messages.push({
          role: msg.sender === "user" ? "user" : "assistant",
          content: msg.content
        });
      }
    });
  
  return messages;
}

// Add the new setup to the init function
function init() {
  console.log("Initializing app...");
  
  try {
    loadPersistedSettings();
    console.log("Settings loaded");
    
    // Update CoD prompt with the correct word limit
    updateCoDPrompt();
    console.log("CoD prompt updated");
    
    createNewThread();
    console.log("New thread created");
    
    initEventListeners();
    console.log("Event listeners initialized");
    
    // NEW: Initialize image upload functionality
    setupImageUpload();
    console.log("Image upload functionality initialized");
    
    updateCurrentModelDisplay();
    console.log("Model display updated");
    
    // ... [rest of the existing init function] ...
  } catch (err) {
    console.error("Initialization error:", err);
  }
}
    function init() {
      console.log("Initializing app...");
      
      try {
        loadPersistedSettings();
        console.log("Settings loaded");
        
        // Update CoD prompt with the correct word limit
        updateCoDPrompt();
        console.log("CoD prompt updated");
        
        createNewThread();
        console.log("New thread created");
        
        initEventListeners();
        console.log("Event listeners initialized");
        
        updateCurrentModelDisplay();
        console.log("Model display updated");
        
        // Initialize feedback form
        initFeedbackForm();
        console.log("Feedback form initialized");
        
        // Helper function to create a button that resets the thread
        function createClearThreadButton() {
          const clearThreadBtn = document.createElement("button");
          clearThreadBtn.id = "clearThreadBtn";
          clearThreadBtn.textContent = "Clear Thread";
          clearThreadBtn.style.marginTop = "0.5rem";
          clearThreadBtn.style.backgroundColor = "#553333";
          clearThreadBtn.addEventListener("click", () => {
            if (confirm("Clear all messages in this thread?")) {
              const thread = threads.find(t => t.id === currentThreadId);
              if (thread) {
                thread.messages = [];
                renderCurrentThreadMessages();
                showNotification("Thread cleared");
              }
            }
          });
          return clearThreadBtn;
        }
        
        // Add clear thread button to the sidebar
        const sidebar = document.querySelector(".sidebar");
        if (sidebar) {
          sidebar.appendChild(createClearThreadButton());
        }
        
        // If we don't have a model name, open settings modal
        if (!MODEL_NAME) {
          console.log("No model name found, opening settings");
          setTimeout(() => {
            try {
              openSettingsModal();
              console.log("Settings modal opened");
            } catch (err) {
              console.error("Error opening settings modal:", err);
            }
          }, 1000);
        }
      } catch (err) {
        console.error("Initialization error:", err);
      }
    }

    // Initialize the application
    document.addEventListener("DOMContentLoaded", init);
    
    // Backup initialization - in case the DOMContentLoaded event already fired
    if (document.readyState === "complete" || document.readyState === "interactive") {
      setTimeout(init, 1);
    }
  </script>
  <form name="feedback" netlify netlify-honeypot="bot-field" hidden>
    <input type="hidden" name="form-name" value="feedback">
    <input type="hidden" name="model">
    <input type="hidden" name="reasoning_method">
    <select name="feedback_type"></select>
    <input type="radio" name="rating" value="1">
    <input type="radio" name="rating" value="2">
    <input type="radio" name="rating" value="3">
    <input type="radio" name="rating" value="4">
    <input type="radio" name="rating" value="5">
    <textarea name="comments"></textarea>
  </form>
</body>
</html>
