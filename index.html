<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>LLM Playground (COT vs COD)</title>
  <!-- Google Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500&family=Roboto+Mono:wght@400;500&display=swap" rel="stylesheet">
  <style>
    /* --------------------------------
       Global Styles
    -------------------------------- */
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      padding: 0;
      font-family: 'Roboto', sans-serif;
      background: linear-gradient(145deg, #0F0F0F 0%, #1F1F1F 100%);
      color: #e0e0e0;
      overflow: hidden;
    }
    .app-container {
      display: flex;
      height: 100vh;
      overflow: hidden;
    }
    /* --------------------------------
       Sidebar Styles
    -------------------------------- */
    .sidebar {
      width: 250px;
      background-color: rgba(30, 30, 30, 0.95);
      padding: 1rem;
      border-right: 1px solid #333;
      overflow-y: auto;
      box-shadow: 2px 0 5px rgba(0,0,0,0.4);
    }
    .sidebar h2 {
      margin-top: 0;
      margin-bottom: 1rem;
      font-size: 1.2rem;
      color: #fff;
    }
    .sidebar ul {
      list-style: none;
      padding: 0;
      margin: 0;
    }
    .sidebar li {
      padding: 0.5rem;
      margin-bottom: 0.5rem;
      border-radius: 8px;
      cursor: pointer;
      transition: background-color 0.3s ease;
    }
    .sidebar li:hover {
      background-color: #333;
    }
    .sidebar li.active {
      background-color: #444;
    }
    .sidebar button {
      width: 100%;
      margin-top: 0.5rem;
      padding: 0.5rem;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-size: 0.9rem;
      transition: background-color 0.3s ease;
      box-shadow: 0 1px 3px rgba(0,0,0,0.4);
    }
    /* Normal button style */
    .sidebar button:not(#downloadTxtBtn):not(#downloadPdfBtn) {
      background-color: #3a3a3a;
      color: #fff;
    }
    .sidebar button:not(#downloadTxtBtn):not(#downloadPdfBtn):hover {
      background-color: #4a4a4a;
    }
    /* Visual Studio–like style for PDF/TXT download buttons */
    #downloadTxtBtn,
    #downloadPdfBtn {
      background-color: #1e1e1e;
      color: #d4d4d4;
      border: 1px solid #3c3c3c;
    }
    #downloadTxtBtn:hover,
    #downloadPdfBtn:hover {
      background-color: #2d2d2d;
    }
    /* --------------------------------
       Chat Container Styles
    -------------------------------- */
    .chat-container {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      background: linear-gradient(145deg, #181818 0%, #202020 100%);
      position: relative;
    }
    .chat-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1rem;
      background-color: rgba(30,30,30,0.95);
      border-bottom: 1px solid #333;
      box-shadow: 0 2px 4px rgba(0,0,0,0.5);
      z-index: 1;
    }
    .chat-header h1#pageTitle {
      margin: 0;
      font-size: 1.5rem;
      color: #fff;
      user-select: none;
    }
    .settings-btn {
      background: none;
      border: none;
      color: #fff;
      font-size: 1.2rem;
      cursor: pointer;
      margin-left: 0.5rem;
      transition: color 0.3s ease;
    }
    .settings-btn:hover {
      color: #ccc;
    }
    .chat-messages {
      flex: 1;
      padding: 1rem;
      overflow-y: auto;
      scroll-behavior: smooth;
    }
    .chat-input {
      display: flex;
      border-top: 1px solid #333;
      background-color: rgba(30,30,30,0.95);
      padding: 1rem;
      box-shadow: 0 -2px 4px rgba(0,0,0,0.3);
    }
    .chat-input textarea {
      flex: 1;
      resize: none;
      border: none;
      background-color: #2e2e2e;
      color: #fff;
      padding: 0.5rem;
      border-radius: 8px;
      font-size: 1rem;
      outline: none;
      box-shadow: inset 0 1px 3px rgba(0,0,0,0.4);
    }
    .chat-input button {
      margin-left: 1rem;
      padding: 0.5rem 1rem;
      background-color: #3a3a3a;
      border: none;
      color: #fff;
      border-radius: 8px;
      cursor: pointer;
      font-size: 1rem;
      transition: background-color 0.3s ease;
      box-shadow: 0 1px 3px rgba(0,0,0,0.4);
    }
    .chat-input button:hover {
      background-color: #4a4a4a;
    }
    /* --------------------------------
       Message Styles
    -------------------------------- */
    .message {
      clear: both;
      margin-bottom: 1.5rem;
      max-width: 80%;
      padding: 0.75rem 1rem;
      border-radius: 12px;
      line-height: 1.4;
      word-wrap: break-word;
      background-color: #2e2e2e;
      border: 1px solid #444;
      box-shadow: 0 1px 3px rgba(0,0,0,0.3);
      position: relative;
      overflow: hidden;
    }
    .message.user {
      float: right;
      background-color: #3a3a3a;
      margin-left: 20%;
    }
    .message.bot {
      float: left;
      background-color: #2e2e2e;
      margin-right: 20%;
    }
    .message.bot.placeholder {
      font-style: italic;
      color: #888;
    }
    /* IMPROVED: Thinking steps and final answer styling */
    .message-container {
      width: 100%;
      overflow: hidden;
    }
    .thinking-steps {
      background-color: #252525;
      border: 1px solid #333;
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 15px;
      font-family: 'Roboto Mono', monospace;
      font-size: 0.85rem;
      color: #aaa;
      white-space: pre-wrap;
      overflow-x: auto;
    }
    .thinking-label {
      font-size: 0.7rem;
      font-family: 'Roboto', sans-serif;
      color: #777;
      margin-bottom: 8px;
      text-transform: uppercase;
      letter-spacing: 1px;
      font-weight: bold;
      border-bottom: 1px dotted #555;
      padding-bottom: 5px;
    }
    .final-answer {
      background-color: #2d3748;
      border: 1px solid #4a5568;
      border-radius: 8px;
      padding: 15px;
      margin-top: 5px;
      color: #edf2f7;
    }
    .final-answer-label {
      font-size: 0.7rem;
      color: #90cdf4;
      margin-bottom: 8px;
      text-transform: uppercase;
      letter-spacing: 1px;
      font-weight: bold;
      border-bottom: 1px dotted #5a7299;
      padding-bottom: 5px;
    }
    .step {
      border-left: 2px solid #3a4a5c;
      padding-left: 10px;
      margin-bottom: 8px;
    }
    .word-count-badge {
      position: absolute;
      top: 10px;
      right: 10px;
      background-color: rgba(30, 30, 30, 0.9);
      color: #ddd;
      font-size: 0.7rem;
      padding: 3px 8px;
      border-radius: 12px;
      border: 1px solid #555;
      box-shadow: 0 1px 3px rgba(0,0,0,0.3);
      white-space: nowrap;
      z-index: 5;
    }
    /* --------------------------------
       Code Block Styles
    -------------------------------- */
    pre {
      background-color: #1f1f1f;
      padding: 0.75rem;
      border-radius: 8px;
      overflow-x: auto;
      margin: 0.5rem 0;
      position: relative;
    }
    code {
      font-family: Consolas, monospace;
      color: #dcdcdc;
    }
    .code-block-container {
      position: relative;
      margin: 0.5rem 0;
      background-color: #1f1f1f;
      border-radius: 8px;
      box-shadow: inset 0 1px 3px rgba(0,0,0,0.3);
      padding: 0.75rem;
    }
    .copy-btn {
      position: absolute;
      top: 8px;
      right: 8px;
      background-color: #333;
      border: none;
      color: #fff;
      border-radius: 4px;
      padding: 4px 8px;
      font-size: 0.8rem;
      cursor: pointer;
      transition: background-color 0.2s ease;
    }
    .copy-btn:hover {
      background-color: #444;
    }
    /* --------------------------------
       Modal Styles - IMPROVED
    -------------------------------- */
    .modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      overflow-y: auto; /* Changed from auto to allow scrolling */
      background-color: rgba(0, 0, 0, 0.7);
      backdrop-filter: blur(3px);
    }
    .modal-content {
      background-color: #1e1e1e;
      margin: 5% auto;
      padding: 20px;
      border: 1px solid #333;
      width: 600px; /* Wider to accommodate settings */
      max-width: 90%; /* Ensure it works on mobile */
      border-radius: 10px;
      color: #fff;
      box-shadow: 0 4px 10px rgba(0,0,0,0.5);
      position: relative;
      max-height: 85vh; /* Limit height and enable scrolling */
      overflow-y: auto;
    }
    .modal-content label {
      display: block;
      margin-bottom: 5px;
      font-size: 0.9rem;
    }
    .modal-content input, .modal-content select {
      width: 100%;
      padding: 0.4rem;
      margin-bottom: 1rem;
      border: 1px solid #333;
      border-radius: 5px;
      background-color: #2e2e2e;
      color: #fff;
      font-size: 0.9rem;
      outline: none;
      box-shadow: inset 0 1px 3px rgba(0,0,0,0.4);
    }
    .modal-content select {
      appearance: none;
      background-image: url("data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23FFFFFF%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E");
      background-repeat: no-repeat;
      background-position: right 0.7em top 50%;
      background-size: 0.65em auto;
      padding-right: 20px;
    }
    .modal-content button {
      padding: 0.5rem 1rem;
      background-color: #3a3a3a;
      border: none;
      color: #fff;
      border-radius: 5px;
      cursor: pointer;
      font-size: 1rem;
      margin-right: 0.5rem;
      transition: background-color 0.3s ease;
      box-shadow: 0 1px 3px rgba(0,0,0,0.4);
    }
    .modal-content button:hover {
      background-color: #4a4a4a;
    }
    .settings-tabs {
      display: flex;
      gap: 5px;
      margin-bottom: 15px;
    }
    .tab-btn {
      flex: 1;
      background-color: #2a2a2a;
      border: 1px solid #444;
      color: #aaa;
      padding: 8px 0;
      border-radius: 5px 5px 0 0;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    .tab-btn.active {
      background-color: #3a3a3a;
      color: #fff;
      border-bottom: 2px solid #4a8cff;
    }
    .tab-content {
      display: none;
      padding: 15px;
      background-color: #2a2a2a;
      border-radius: 0 0 5px 5px;
      margin-bottom: 20px;
    }
    .tab-content.active {
      display: block;
    }
    .checkbox-container {
      display: flex;
      align-items: center;
      margin-bottom: 10px;
    }
    .checkbox-container input[type="checkbox"] {
      width: auto;
      margin-right: 10px;
      margin-bottom: 0;
    }
    .tooltip {
      position: relative;
      display: inline-block;
      margin-left: 5px;
      cursor: help;
    }
    .tooltip .tooltiptext {
      visibility: hidden;
      width: 300px;
      background-color: #2e2e2e;
      color: #fff;
      text-align: left;
      border-radius: 6px;
      padding: 8px;
      position: absolute;
      z-index: 1;
      top: -5px;
      left: 105%;
      opacity: 0;
      transition: opacity 0.3s;
      box-shadow: 0 2px 5px rgba(0,0,0,0.3);
      font-size: 0.8rem;
      line-height: 1.4;
    }
    .tooltip:hover .tooltiptext {
      visibility: visible;
      opacity: 1;
    }
    
    /* --------------------------------
       Reasoning Method UI Improvements
    -------------------------------- */
    .feature-section {
      border: 1px solid #444;
      border-radius: 8px;
      padding: 12px;
      margin-bottom: 16px;
      background-color: #2a2a2a;
    }
    
    .feature-header {
      display: flex;
      align-items: center;
      margin-bottom: 10px;
    }
    
    .feature-header input[type="checkbox"] {
      margin-right: 8px;
    }
    
    .feature-header label {
      font-weight: 500;
      font-size: 1rem;
    }
    
    .feature-options {
      margin-left: 24px;
      padding-top: 8px;
      border-top: 1px solid #444;
    }
    
    .option-label {
      margin-bottom: 8px;
      color: #bbb;
      font-size: 0.9rem;
    }
    
    .radio-options {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-bottom: 10px;
    }
    
    .radio-option {
      display: flex;
      align-items: center;
    }
    
    .radio-option input[type="radio"] {
      margin-right: 8px;
      width: auto;
      cursor: pointer;
    }
    
    .radio-option label {
      cursor: pointer;
      margin-bottom: 0;
    }
    
    /* Make radio buttons more visible and clickable */
    input[type="radio"] {
      -webkit-appearance: none;
      -moz-appearance: none;
      appearance: none;
      border-radius: 50%;
      width: 16px;
      height: 16px;
      border: 2px solid #555;
      outline: none;
      margin-right: 8px;
      position: relative;
      cursor: pointer;
    }
    
    input[type="radio"]:checked {
      border-color: #4a8cff;
    }
    
    input[type="radio"]:checked:before {
      content: '';
      position: absolute;
      top: 3px;
      left: 3px;
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: #4a8cff;
    }
    
    /* Make checkboxes more visible and clickable */
    input[type="checkbox"] {
      -webkit-appearance: none;
      -moz-appearance: none;
      appearance: none;
      width: 16px;
      height: 16px;
      border: 2px solid #555;
      border-radius: 3px;
      outline: none;
      cursor: pointer;
      position: relative;
    }
    
    input[type="checkbox"]:checked {
      border-color: #4a8cff;
      background-color: #4a8cff;
    }
    
    input[type="checkbox"]:checked:before {
      content: '✓';
      position: absolute;
      color: white;
      font-size: 12px;
      top: -1px;
      left: 2px;
    }
    
    .tooltip {
      margin-left: 6px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 16px;
      height: 16px;
      background-color: #555;
      border-radius: 50%;
      font-size: 12px;
      cursor: help;
    }

    /* Status notification */
    .status-notification {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background-color: #2a2a2a;
      color: white;
      padding: 10px 15px;
      border-radius: 4px;
      box-shadow: 0 3px 6px rgba(0,0,0,0.3);
      z-index: 1001;
      display: none;
      opacity: 0;
      transition: opacity 0.3s ease;
    }
    
    .status-notification.show {
      display: block;
      opacity: 1;
    }
    
    /* Better modal close button */
    .close-modal {
      position: absolute;
      top: 15px;
      right: 15px;
      background: none;
      border: none;
      color: #aaa;
      font-size: 20px;
      cursor: pointer;
      padding: 0;
      margin: 0;
      transition: color 0.2s ease;
    }
    
    .close-modal:hover {
      color: #eee;
    }
    
    /* Current model display */
    .current-model-display {
      display: inline-block;
      padding: 4px 8px;
      border-radius: 4px;
      background-color: #253245;
      color: #fff;
      font-size: 0.9rem;
      margin-left: 10px;
    }
    
    .reasoning-badge {
      display: inline-block;
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 0.7rem;
      margin-left: 5px;
      background-color: #444;
    }
    
    /* Two column layout for some settings */
    .settings-row {
      display: flex;
      gap: 20px;
      margin-bottom: 15px;
    }
    
    .settings-column {
      flex: 1;
    }
    
    /* Prompt editing styles */
    .prompt-editor {
      margin-top: 15px;
    }
    
    .prompt-editor textarea {
      width: 100%;
      min-height: 150px;
      background-color: #252525;
      color: #ddd;
      border: 1px solid #444;
      border-radius: 5px;
      padding: 10px;
      font-family: monospace;
      font-size: 0.9rem;
      line-height: 1.4;
      resize: vertical;
    }
    
    .prompt-reset {
      margin-top: 5px;
      font-size: 0.8rem;
      color: #aaa;
      cursor: pointer;
      text-decoration: underline;
    }
    
    .prompt-reset:hover {
      color: #4a8cff;
    }

    /* Enhanced styles for Chain of Draft */
    .cod-thinking {
      background-color: #1e293b !important;
      border-color: #3d4e63 !important;
    }

    .cod-step {
      display: flex;
      align-items: flex-start;
      padding: 6px 8px;
      margin-bottom: 10px !important;
      border-left: none !important;
      background-color: #2c3b4f;
      border-radius: 6px;
      box-shadow: 0 1px 2px rgba(0,0,0,0.2);
    }

    .step-number {
      display: flex;
      align-items: center;
      justify-content: center;
      min-width: 24px;
      height: 24px;
      background-color: #3d4f69;
      border-radius: 12px;
      margin-right: 10px;
      color: #a3c5e9;
      font-size: 0.75rem;
      font-weight: bold;
    }

    .step-content {
      flex: 1;
      padding-right: 8px;
      font-family: 'Roboto Mono', monospace;
      color: #c5d5e8;
    }

    /* Enhanced token display */
    .token-savings {
      font-size: 0.7rem;
      color: #4ade80;
      margin-left: 5px;
    }

    /* COD Word Limit options */
    .cod-options {
      margin-top: 15px;
      display: none;
    }

    .cod-word-limit-options {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-bottom: 15px;
    }

    .cod-word-limit-option {
      display: flex;
      align-items: center;
      padding: 8px 12px;
      margin-bottom: 8px;
      background-color: #2a2a2a;
      border-radius: 6px;
      cursor: pointer;
      transition: background-color 0.2s ease;
    }

    .cod-word-limit-option:hover {
      background-color: #333;
    }

    .cod-word-limit-option.selected {
      background-color: #3a4a5c;
      border-left: 3px solid #4a8cff;
    }

    .cod-word-limit-value {
      font-weight: bold;
      margin-right: 5px;
    }

    .cod-word-limit-desc {
      font-size: 0.85rem;
      color: #aaa;
    }

    /* CoD examples section */
    .cod-examples {
      margin-top: 15px;
      padding: 15px;
      background-color: #2a2a2a;
      border-radius: 8px;
      border: 1px solid #444;
    }

    .cod-examples-header {
      font-size: 0.9rem;
      font-weight: bold;
      margin-bottom: 10px;
      color: #ddd;
      border-bottom: 1px solid #444;
      padding-bottom: 5px;
    }

    .cod-example-item {
      margin-bottom: 12px;
      font-family: 'Roboto Mono', monospace;
      font-size: 0.85rem;
      padding: 8px;
      background-color: #333;
      border-radius: 5px;
      color: #bbb;
    }

    .cod-example-question {
      color: #aaa;
      margin-bottom: 5px;
    }

    .cod-example-answer {
      color: #4a8cff;
    }

    /* Responsive adjustments */
    @media (max-width: 768px) {
      .app-container {
        flex-direction: column;
      }
      
      .sidebar {
        width: 100%;
        max-height: 200px;
      }
      
      .message {
        max-width: 85%;
      }
      
      .settings-row {
        flex-direction: column;
        gap: 10px;
      }
    }
  </style>
</head>
<body>
  <!-- Include jsPDF for PDF generation -->
  <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>

  <div class="app-container">
    <!-- Sidebar for Thread Management -->
    <div class="sidebar">
      <h2>Threads</h2>
      <ul id="threadList"></ul>
      <button id="newThreadBtn">New Thread</button>
      <button id="deleteThreadBtn">Delete Thread</button>
      <button id="downloadTxtBtn">Download TXT</button>
      <button id="downloadPdfBtn">Download PDF</button>
    </div>

    <!-- Chat Area -->
    <div class="chat-container">
      <div class="chat-header">
        <h1 id="pageTitle">LLM Playground (COT vs COD)</h1>
        <div>
          <span id="currentModelDisplay" class="current-model-display">Model not set</span>
          <button class="settings-btn" id="openSettings">Settings ⚙️</button>
        </div>
      </div>
      <div class="chat-messages" id="chatMessages">
        <!-- Chat messages will be rendered here -->
      </div>
      <div class="chat-input">
        <textarea id="userInput" rows="2" placeholder="Type your message..."></textarea>
        <button id="sendBtn">Send</button>
      </div>
    </div>
  </div>

  <!-- Status Notification -->
  <div id="statusNotification" class="status-notification"></div>

  <!-- Settings Modal -->
  <div id="settingsModal" class="modal">
    <div class="modal-content">
      <button class="close-modal" id="closeModalX">&times;</button>
      <h2>Settings</h2>
      
      <div class="settings-tabs">
        <button class="tab-btn active" data-tab="modelTab">Model</button>
        <button class="tab-btn" data-tab="reasoningTab">Reasoning</button>
        <button class="tab-btn" data-tab="parametersTab">Parameters</button>
      </div>
      
      <!-- Model Selection Tab -->
      <div id="modelTab" class="tab-content active">
        <div class="settings-section-header">Model Configuration</div>
        <label for="modelName">Model Name/Path</label>
        <input type="text" id="modelName" placeholder="Enter full model name/path from Fireworks.ai">
        <p style="font-size: 0.8rem; color: #aaa; margin-top: 0; margin-bottom: 15px;">Enter the complete model identifier as used in Fireworks.ai API.</p>
        
        <button id="setModelBtn">Set Model</button>
      </div>
      
      <!-- Reasoning Tab -->
      <div id="reasoningTab" class="tab-content">
        <div class="settings-section-header">Reasoning Method</div>
        <div class="feature-section">
          <div class="radio-options">
            <div class="radio-option">
              <input type="radio" id="standardReasoning" name="reasoningMethod" value="standard">
              <label for="standardReasoning">Standard (No special prompt)</label>
              <div class="tooltip">?
                <span class="tooltiptext">Default model behavior with no special reasoning instructions.</span>
              </div>
            </div>
            
            <div class="radio-option">
              <input type="radio" id="cotReasoning" name="reasoningMethod" value="cot">
              <label for="cotReasoning">Chain of Thought (CoT)</label>
              <div class="tooltip">?
                <span class="tooltiptext">Instructs the model to think step-by-step to solve problems. Improves reasoning but uses more tokens.</span>
              </div>
            </div>
            
            <div class="radio-option">
              <input type="radio" id="codReasoning" name="reasoningMethod" value="cod" checked>
              <label for="codReasoning">Chain of Draft (CoD)</label>
              <div class="tooltip">?
                <span class="tooltiptext">Uses minimal words per step (research paper approach) to reduce token usage while maintaining reasoning quality.</span>
              </div>
            </div>
          </div>
          
          <!-- COD Word Limit options -->
          <div id="codOptions" class="cod-options">
            <!-- This will be populated by the updateCoDOptionsUI function -->
          </div>
        </div>
      </div>
      
      <!-- Parameters Tab -->
      <div id="parametersTab" class="tab-content">
        <div class="settings-section-header">Generation Parameters</div>
        
        <!-- Improved range sliders with visible values -->
        <label for="temp">Temperature</label>
        <div class="range-container">
          <input type="range" id="temp" min="0" max="1" step="0.01" value="0.5">
          <span id="tempValue" class="range-value">0.5</span>
        </div>
        <p style="font-size: 0.8rem; color: #aaa; margin-top: 0;">Controls randomness: lower values make responses more focused and deterministic.</p>

        <label for="topP">Top P</label>
        <div class="range-container">
          <input type="range" id="topP" min="0" max="1" step="0.01" value="0.90">
          <span id="topPValue" class="range-value">0.90</span>
        </div>
        <p style="font-size: 0.8rem; color: #aaa; margin-top: 0;">Controls diversity via nucleus sampling: lower values exclude less probable tokens.</p>

        <label for="topK">Top K</label>
        <div class="range-container">
          <input type="range" id="topK" min="0" max="100" step="1" value="55">
          <span id="topKValue" class="range-value">55</span>
        </div>
        <p style="font-size: 0.8rem; color: #aaa; margin-top: 0;">Limits sampling to the top K most likely tokens.</p>

        <label for="maxTokens">Max Tokens</label>
        <div class="range-container">
          <input type="range" id="maxTokens" min="256" max="4096" step="128" value="1112">
          <span id="maxTokensValue" class="range-value">1112</span>
        </div>
        <p style="font-size: 0.8rem; color: #aaa; margin-top: 0;">Maximum number of tokens to generate in the response.</p>

        <label for="presencePenalty">Presence Penalty</label>
        <div class="range-container">
          <input type="range" id="presencePenalty" min="-2" max="2" step="0.1" value="0">
          <span id="presencePenaltyValue" class="range-value">0</span>
        </div>
        <p style="font-size: 0.8rem; color: #aaa; margin-top: 0;">Penalizes new tokens based on their presence in the input.</p>

        <label for="frequencyPenalty">Frequency Penalty</label>
        <div class="range-container">
          <input type="range" id="frequencyPenalty" min="-2" max="2" step="0.1" value="0.4">
          <span id="frequencyPenaltyValue" class="range-value">0.4</span>
        </div>
        <p style="font-size: 0.8rem; color: #aaa; margin-top: 0;">Penalizes tokens based on their frequency in the generated text.</p>
      </div>
      
      <div style="text-align: right; margin-top: 20px;">
        <button id="saveSettings">Save</button>
        <button id="closeSettings">Cancel</button>
      </div>
    </div>
  </div>

  <!-- Feedback Button and Modal -->
  <div style="position: fixed; bottom: 20px; left: 20px; z-index: 1000;">
    <button id="openFeedbackBtn" style="background-color: #4a8cff; color: white; border: none; padding: 10px 15px; border-radius: 20px; cursor: pointer; box-shadow: 0 2px 5px rgba(0,0,0,0.3);">
      <span style="margin-right: 5px;">💬</span> Feedback
    </button>
  </div>

  <div id="feedbackModal" class="modal">
    <div class="modal-content" style="max-width: 500px;">
      <button class="close-modal" id="closeFeedbackModal">&times;</button>
      <h2>Share Your Feedback</h2>
      
      <form name="feedback" method="POST" data-netlify="true">
        <input type="hidden" name="form-name" value="feedback">
        
        <input type="hidden" id="feedbackModel" name="model">
        <input type="hidden" id="feedbackReasoning" name="reasoning_method">
        
        <label for="feedbackType">Feedback Type:</label>
        <select id="feedbackType" name="feedback_type" style="width: 100%; margin-bottom: 15px;">
          <option value="general">General Feedback</option>
          <option value="bug">Report a Bug</option>
          <option value="feature">Feature Request</option>
          <option value="model_performance">Model Performance</option>
        </select>
        
        <label>How would you rate your experience?</label>
        <div style="display: flex; justify-content: space-between; margin: 10px 0 15px 0;">
          <label style="flex: 1; text-align: center;">
            <input type="radio" name="rating" value="1" required>
            <div>😞</div>
            <div style="font-size: 0.8rem;">Poor</div>
          </label>
          <label style="flex: 1; text-align: center;">
            <input type="radio" name="rating" value="2">
            <div>😐</div>
            <div style="font-size: 0.8rem;">Fair</div>
          </label>
          <label style="flex: 1; text-align: center;">
            <input type="radio" name="rating" value="3">
            <div>🙂</div>
            <div style="font-size: 0.8rem;">Good</div>
          </label>
          <label style="flex: 1; text-align: center;">
            <input type="radio" name="rating" value="4">
            <div>😀</div>
            <div style="font-size: 0.8rem;">Great</div>
          </label>
          <label style="flex: 1; text-align: center;">
            <input type="radio" name="rating" value="5">
            <div>🤩</div>
            <div style="font-size: 0.8rem;">Excellent</div>
          </label>
        </div>
        
        <label for="feedbackComments">Comments:</label>
        <textarea 
          id="feedbackComments" 
          name="comments" 
          rows="4" 
          style="width: 100%; background-color: #2e2e2e; color: #fff; border: 1px solid #444; border-radius: 5px; padding: 10px; margin-bottom: 20px;"
          required
        ></textarea>
        
        <button 
          type="submit" 
          style="background-color: #4a8cff; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; float: right;"
        >
          Submit Feedback
        </button>
      </form>
    </div>
  </div>

  <script>
    /***********************
     * Global Configuration
     ***********************/
    let MODEL_NAME = "";
    let MODEL_NAME_DISPLAY = "";
    
    // Server endpoint (Netlify serverless function)
    const API_PROXY_URL = "/.netlify/functions/api-proxy";
    
    // Reasoning Method
    let REASONING_METHOD = "cod"; // Options: "standard", "cot", "cod"
    
    // COD Word Limit
    let COD_WORD_LIMIT = 5;
    
    // Prompts for different reasoning methods
    let PROMPTS = {
      standard: "",
      cot: `Think step by step to solve this problem. Explain your reasoning at each step, then provide your final answer.`,
      
      cod: `Think step by step, but produce only minimal notes for each step (${COD_WORD_LIMIT} words maximum per step). Use mathematical notation where possible. Keep only essential information needed to solve the problem. Focus on key calculations and intermediate results without narrative explanation.
  
Separate your steps with periods. Write your final answer after the #### separator.

Examples:
Q: Jason had 20 lollipops. He gave Denny some lollipops. Now Jason has 12 lollipops. How many lollipops did Jason give to Denny?
A: 20 initial. 12 remaining. 20 - 12 = 8. #### 8 lollipops

Q: Roger has $125. He spends $55 on a video game and then receives $25 for his birthday. How much money does Roger have now?
A: Start: $125. Spent: $55. 125 - 55 = $70. Received: $25. 70 + 25 = $95. #### $95

Q: A square has a perimeter of 20 cm. What is its area?
A: Perimeter = 20 cm. Side length = 20/4 = 5 cm. Area = 5² = 25 cm². #### 25 square centimeters

Q: If a fabric store received 45 yards of cotton material and used 2/9 of it for a bulk order, how many yards of cotton material does the fabric store have left?
A: Total: 45 yards. Used: 2/9 × 45 = 10 yards. Remaining: 45 - 10 = 35 yards. #### 35 yards

Q: The temperature on Monday was -3°C. On Tuesday, it was 14°C. What was the change in temperature from Monday to Tuesday?
A: Monday: -3°C. Tuesday: 14°C. Change: 14 - (-3) = 17°C. #### 17°C`
    };
    
    // Default generation parameters
    let TEMPERATURE = 0.5;
    let TOP_P = 0.90;
    let TOP_K = 55;
    let MAX_TOKENS = 1112;
    let PRESENCE_PENALTY = 0;
    let FREQUENCY_PENALTY = 0.4;

    function getModelDisplayName(fullStr) {
      if (!fullStr) return "Model not set";
      
      // Extract from path
      const parts = fullStr.split("/");
      const lastChunk = parts[parts.length - 1] || "";
      const dashIndex = lastChunk.lastIndexOf("-");
      if (dashIndex !== -1) {
        return lastChunk.substring(0, dashIndex);
      }
      return lastChunk;
    }
    
    function updateCurrentModelDisplay() {
      const element = document.getElementById("currentModelDisplay");
      if (element) {
        let displayText = getModelDisplayName(MODEL_NAME);
        
        // Add badge for reasoning method
        let reasoningBadge = "";
        switch (REASONING_METHOD) {
          case "cot":
            reasoningBadge = '<span class="reasoning-badge" style="background-color: #2c6b9c;">CoT</span>';
            break;
          case "cod":
            reasoningBadge = `<span class="reasoning-badge" style="background-color: #2c6b9c;">CoD-${COD_WORD_LIMIT}</span>`;
            break;
        }
        
        element.innerHTML = displayText + reasoningBadge;
      }
    }

    /***********************
     * Thread Management
     ***********************/
    let threads = [];
    let currentThreadId = null;
    let threadCounter = 1;

    function createNewThread() {
      const newThread = {
        id: Date.now(),
        name: `Thread ${threadCounter++}`,
        messages: []
      };
      threads.push(newThread);
      currentThreadId = newThread.id;
      updateThreadList();
      renderCurrentThreadMessages();
      
      // Show status notification
      showNotification("New thread created");
    }

    function updateThreadList() {
      const threadList = document.getElementById("threadList");
      threadList.innerHTML = "";
      threads.forEach(thread => {
        const li = document.createElement("li");
        li.textContent = thread.name;
        if (thread.id === currentThreadId) {
          li.classList.add("active");
        }
        li.addEventListener("click", () => {
          currentThreadId = thread.id;
          renderCurrentThreadMessages();
          updateThreadList();
        });
        threadList.appendChild(li);
      });
    }

    function deleteCurrentThread() {
      if (!currentThreadId) return;
      if (confirm("Are you sure you want to delete this thread?")) {
        threads = threads.filter(thread => thread.id !== currentThreadId);
        if (threads.length > 0) {
          currentThreadId = threads[0].id;
        } else {
          createNewThread();
          return;
        }
        updateThreadList();
        renderCurrentThreadMessages();
        showNotification("Thread deleted");
      }
    }

    /************************************************
     * Helper: Parse Content for Export
     ************************************************/
    function parseContentForExport(content) {
      const result = [];
      const segments = content.split(/```/);
      for (let i = 0; i < segments.length; i++) {
        if (i % 2 === 0) {
          // Normal text
          const textLines = segments[i].split(/\r?\n/);
          textLines.forEach(line => {
            result.push({ type: 'text', content: line });
          });
        } else {
          // Code block
          const codeSegment = segments[i].trim();
          const firstNewlineIndex = codeSegment.indexOf('\n');
          let language = '';
          let codeContent = codeSegment;
          if (firstNewlineIndex !== -1) {
            const possibleLang = codeSegment.substring(0, firstNewlineIndex).trim();
            if (possibleLang && !possibleLang.includes(' ')) {
              language = possibleLang;
              codeContent = codeSegment.substring(firstNewlineIndex + 1);
            }
          }
          const codeLines = codeContent.split(/\r?\n/);
          result.push({ type: 'code', language: language, content: codeLines });
        }
      }
      return result;
    }

    /***********************
     * Word Counting Utility - IMPROVED FOR COD
     ***********************/
    function countWords(text) {
      // Remove code blocks to get more accurate word count for actual text
      const textWithoutCode = text.replace(/```[\s\S]*?```/g, '');
      
      // Count mathematical expressions as single words
      // First, replace common math expressions with placeholder words
      let processedText = textWithoutCode
        // Replace simple equations (e.g., "x = 5 + 3") with single tokens
        .replace(/\b\w+\s*=\s*[\d\w+\-*/()]+/g, "EQUATION")
        // Replace fractions (e.g., "2/3") with single tokens
        .replace(/\b\d+\/\d+\b/g, "FRACTION")
        // Replace mathematical operations with spaces
        .replace(/[+\-*/=<>]+/g, " ");
      
      // Split by whitespace and filter out empty strings
      const words = processedText.split(/\s+/).filter(word => word.length > 0);
      return words.length;
    }

    /***********************
     * Download as TXT
     ***********************/
    function downloadCurrentThreadAsTxt() {
      const thread = threads.find(t => t.id === currentThreadId);
      if (!thread) return;

      let content = `Model: ${MODEL_NAME_DISPLAY} (${REASONING_METHOD.toUpperCase()}`;
      if (REASONING_METHOD === "cod") {
        content += `-${COD_WORD_LIMIT}`;
      }
      content += `)\n\n`;

      thread.messages.forEach(msg => {
        const prefix = msg.sender.toUpperCase();
        
        // Add word count info for bot messages
        let headerInfo = prefix;
        if (msg.sender === "bot" && !msg.isPlaceholder && msg.wordCount !== undefined) {
          headerInfo += ` [${msg.wordCount} words - ${msg.reasoningMethod || REASONING_METHOD.toUpperCase()}]`;
        }
        
        content += `${headerInfo}:\n`;
        
        // Special handling for messages with thinking/answer components
        if (msg.sender === "bot" && msg.thinking && msg.answer) {
          content += `THINKING STEPS:\n${msg.thinking}\n\nFINAL ANSWER:\n${msg.answer}\n`;
        } else {
          const parsed = parseContentForExport(msg.content);
          parsed.forEach(item => {
            if (item.type === 'text') {
              content += item.content + '\n';
            } else if (item.type === 'code') {
              const lang = item.language ? ` (${item.language})` : '';
              content += `----- CODE BLOCK START${lang} -----\n`;
              item.content.forEach(line => {
                content += `  ${line}\n`;
              });
              content += `----- CODE BLOCK END -----\n`;
            }
          });
        }
        content += '\n';
      });

      const blob = new Blob([content], { type: "text/plain" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = `${thread.name}.txt`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      showNotification("TXT file downloaded");
    }

    /***********************
     * Download as PDF
     ***********************/
    async function downloadCurrentThreadAsPdf() {
      const thread = threads.find(t => t.id === currentThreadId);
      if (!thread) return;

      const { jsPDF } = window.jspdf;
      const doc = new jsPDF({
        unit: "pt",
        format: "letter"
      });

      function setPageBackground(doc) {
        doc.setFillColor(30, 30, 30);
        doc.rect(0, 0, doc.internal.pageSize.width, doc.internal.pageSize.height, 'F');
      }

      setPageBackground(doc);
      doc.setTextColor(224, 224, 224);

      let yPos = 40;
      const lineHeight = 14;
      const leftMargin = 40;

      doc.setFont("helvetica", "bold");
      doc.setFontSize(12);
      let modelInfo = `Model: ${MODEL_NAME_DISPLAY} (${REASONING_METHOD.toUpperCase()}`;
      if (REASONING_METHOD === "cod") {
        modelInfo += `-${COD_WORD_LIMIT}`;
      }
      modelInfo += `)`;
      doc.text(modelInfo, leftMargin, yPos);
      yPos += 20;
      doc.text(thread.name, leftMargin, yPos);
      yPos += 20;

      thread.messages.forEach(msg => {
        doc.setFont("helvetica", "bold");
        doc.setFontSize(10);
        
        // Add word count info for bot messages
        let sender = msg.sender.toUpperCase() + ":";
        if (msg.sender === "bot" && !msg.isPlaceholder && msg.wordCount !== undefined) {
          sender += ` [${msg.wordCount} words - ${msg.reasoningMethod || REASONING_METHOD.toUpperCase()}]`;
        }
        
        doc.text(sender, leftMargin, yPos);
        yPos += lineHeight;

        // Special handling for messages with thinking/answer components
        if (msg.sender === "bot" && !msg.isPlaceholder && (msg.thinking || msg.answer)) {
          // If we have thinking steps, render them
          if (msg.thinking) {
            doc.setFont("helvetica", "italic");
            doc.setFontSize(9);
            doc.setTextColor(180, 180, 180);
            doc.text("THINKING STEPS:", leftMargin, yPos);
            yPos += lineHeight;
            
            doc.setFont("courier", "normal");
            const thinkingLines = msg.thinking.split(/\r?\n/);
            thinkingLines.forEach(line => {
              if (yPos > 720) {
                doc.addPage();
                setPageBackground(doc);
                yPos = 40;
              }
              const wrapped = doc.splitTextToSize(line, 520);
              wrapped.forEach(wLine => {
                doc.text(wLine, leftMargin + 10, yPos);
                yPos += lineHeight;
              });
            });
            
            yPos += lineHeight/2;
          }
          
          // If we have an answer, render it
          if (msg.answer) {
            doc.setFont("helvetica", "bold");
            doc.setFontSize(9);
            doc.setTextColor(144, 205, 244);
            doc.text("FINAL ANSWER:", leftMargin, yPos);
            yPos += lineHeight;
            
            doc.setFont("helvetica", "normal");
            doc.setTextColor(224, 224, 224);
            doc.setFontSize(10);
            const answerLines = msg.answer.split(/\r?\n/);
            answerLines.forEach(line => {
              if (yPos > 720) {
                doc.addPage();
                setPageBackground(doc);
                yPos = 40;
              }
              const wrapped = doc.splitTextToSize(line, 520);
              wrapped.forEach(wLine => {
                doc.text(wLine, leftMargin + 10, yPos);
                yPos += lineHeight;
              });
            });
          }
        } else {
          // Standard rendering for other messages
          const parsed = parseContentForExport(msg.content);
          parsed.forEach(item => {
            if (item.type === 'text') {
              doc.setFont("helvetica", "normal");
              const line = item.content;
              if (yPos > 720) {
                doc.addPage();
                setPageBackground(doc);
                yPos = 40;
              }
              const wrapped = doc.splitTextToSize(line, 540);
              wrapped.forEach(wLine => {
                doc.text(wLine, leftMargin, yPos);
                yPos += lineHeight;
              });
            } else if (item.type === 'code') {
              doc.setFont("helvetica", "bold");
              const lang = item.language ? ` (${item.language})` : '';
              doc.text(`Code Block${lang}:`, leftMargin, yPos);
              yPos += lineHeight;

              doc.setFont("courier", "normal");
              item.content.forEach(codeLine => {
                if (yPos > 720) {
                  doc.addPage();
                  setPageBackground(doc);
                  yPos = 40;
                }
                const wrapped = doc.splitTextToSize(codeLine, 520);
                wrapped.forEach(wLine => {
                  doc.text(wLine, leftMargin + 20, yPos);
                  yPos += lineHeight;
                });
              });
            }
          });
        }
        yPos += lineHeight;
      });

      doc.save(`${thread.name}.pdf`);
      showNotification("PDF file downloaded");
    }

    /***********************
     * Process Bot Messages - IMPROVED VERSION FOR COD
     ***********************/
    function processBotMessage(content, reasoningMethod) {
      // For Chain of Draft (CoD) mode, extract thinking steps and final answer
      if (reasoningMethod === "cod") {
        const separatorIndex = content.indexOf("####");
        
        if (separatorIndex !== -1) {
          // Extract thinking steps and final answer
          let thinking = content.substring(0, separatorIndex).trim();
          let answer = content.substring(separatorIndex + 4).trim();
          
          return {
            content: content,
            thinking: thinking,
            answer: answer
          };
        } else {
          // Try to identify thinking steps and final answer based on structure
          // Look for phrases that might indicate a conclusion
          const conclusionPhrases = [
            "Therefore", "Thus", "Hence", "So", "Result", "Answer", "Finally", 
            "In conclusion", "The answer is", "This gives us"
          ];
          
          // Split by periods to identify steps
          const parts = content.split('.');
          if (parts.length > 1) {
            // Use the last part as the answer and everything else as thinking
            const lastPart = parts.pop().trim();
            const thinking = parts.join('.').trim();
            
            return {
              content: content,
              thinking: thinking,
              answer: lastPart
            };
          }
        }
      }
      
      // For Chain of Thought (CoT) mode, try to identify a logical final answer section
      if (reasoningMethod === "cot") {
        // Look for potential conclusion markers
        const conclusionMarkers = [
          "Therefore", "In conclusion", "So,", "Thus,", "Hence,", 
          "The answer is", "To conclude", "Finally,", "In summary",
          "As a result", "Consequently", "The final answer"
        ];
        
        // Add a marker for just "Answer:" or "Final answer:" on its own line
        const answerMarkers = [
          /\n(Answer:|Final answer:)/i,
          /^(Answer:|Final answer:)/i,
          /\n(The answer is:|My answer is:|Final answer is:)/i
        ];
        
        // Try each answer marker pattern
        for (const pattern of answerMarkers) {
          const answerMatch = content.match(pattern);
          if (answerMatch && answerMatch.index !== undefined) {
            // Found a marker
            const thinking = content.substring(0, answerMatch.index).trim();
            const answer = content.substring(answerMatch.index + answerMatch[0].length).trim();
            
            return {
              content: content,
              thinking: thinking,
              answer: answer
            };
          }
        }
        
        // If no explicit answer marker, look for conclusion indicator words
        let lastMarkerIndex = -1;
        let bestMarker = "";
        
        for (const marker of conclusionMarkers) {
          // Check for the marker near the end of the text (last 40%)
          const startSearchPos = content.length * 0.6;
          const markerIndex = content.indexOf(marker, startSearchPos);
          
          if (markerIndex > lastMarkerIndex && markerIndex !== -1) {
            lastMarkerIndex = markerIndex;
            bestMarker = marker;
          }
        }
        
        // If we found a conclusion marker in a reasonable position
        if (lastMarkerIndex > content.length * 0.6) {
          const thinking = content.substring(0, lastMarkerIndex).trim();
          const answer = content.substring(lastMarkerIndex).trim();
          
          return {
            content: content,
            thinking: thinking,
            answer: answer
          };
        }
        
        // Last resort: if text has multiple paragraphs, try to use the last paragraph as answer
        const paragraphs = content.split(/\n\s*\n/);
        if (paragraphs.length > 1) {
          const lastParagraph = paragraphs[paragraphs.length - 1].trim();
          // Only use last paragraph as answer if it's relatively short compared to whole text
          if (lastParagraph.length < content.length * 0.3) {
            const thinking = content.substring(0, content.lastIndexOf(lastParagraph)).trim();
            return {
              content: content,
              thinking: thinking,
              answer: lastParagraph
            };
          }
        }
      }
      
      // For standard reasoning
      if (reasoningMethod === "standard") {
        return {
          content: content,
          thinking: null, 
          answer: content
        };
      }
      
      // Default: if unable to separate, return entire content
      return {
        content: content,
        thinking: reasoningMethod === "cot" || reasoningMethod === "cod" ? content : null,
        answer: reasoningMethod === "standard" ? content : null
      };
    }

    /***********************
     * Format Thinking Steps - IMPROVED FOR COD
     ***********************/
    function formatThinkingSteps(thinking, reasoningMethod) {
      if (!thinking) return '';
      
      // Remove any "###" prefixes
      let cleanedThinking = thinking.replace(/^#{1,3}\s*/gm, '');
      
      if (reasoningMethod === "cod") {
        // Split by periods to separate steps for CoD
        let steps = cleanedThinking.split(/\.\s*/).filter(step => step.trim().length > 0);
        
        // Create a more visually distinct format for CoD steps
        return steps.map((step, index) => 
          `<div class="step cod-step">
            <span class="step-number">${index + 1}</span>
            <span class="step-content">${step.trim()}${!step.endsWith('.') ? '.' : ''}</span>
          </div>`
        ).join('');
      } else {
        // Original formatting for CoT
        let steps = cleanedThinking.split(/\.\s+/);
        
        return steps.filter(step => step.trim())
          .map(step => 
            `<div class="step">${step.trim()}${!step.endsWith('.') ? '.' : ''}</div>`
          ).join('');
      }
    }

    /***********************
     * Transform Message
     ***********************/
    function transformMessage(content) {
      // Remove "###" prefixes from lines
      let processedContent = content.replace(/^#{1,3}\s*/gm, '');
      
      // Replace code blocks with syntax highlighting
      const transformed = processedContent.replace(/```([\s\S]*?)```/g, (match, codeContent) => {
        let language = '';
        const lines = codeContent.split('\n');
        if (lines.length > 0 && !lines[0].includes(' ')) {
          language = lines[0].trim();
          lines.shift();
        }
        return `<pre><code class="${language}">${lines.join('\n')}</code></pre>`;
      });
      return transformed;
    }

    /***********************
     * Rendering Messages - IMPROVED VERSION
     ***********************/
    function renderCurrentThreadMessages() {
      const chatMessagesDiv = document.getElementById("chatMessages");
      chatMessagesDiv.innerHTML = "";
      const thread = threads.find(t => t.id === currentThreadId);
      if (thread) {
        thread.messages.forEach(msg => {
          const messageDiv = document.createElement("div");
          messageDiv.classList.add("message", msg.sender);
          if (msg.isPlaceholder) {
            messageDiv.classList.add("placeholder");
          }

          const timestampStr = msg.timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
          const timestampEl = document.createElement("small");
          timestampEl.textContent = timestampStr;
          timestampEl.style.color = "#aaa";
          timestampEl.style.display = "block";
          timestampEl.style.marginBottom = "0.5rem";
          messageDiv.appendChild(timestampEl);

          // Special handling for messages with thinking/answer components
          if (msg.sender === "bot" && !msg.isPlaceholder) {
            const messageContainer = document.createElement("div");
            messageContainer.className = "message-container";
            
            // If we have thinking steps (for CoT or CoD)
            if (msg.thinking) {
              const thinkingDiv = document.createElement("div");
              thinkingDiv.className = "thinking-steps";
              
              // Add different style class for CoD
              if (msg.reasoningMethod && msg.reasoningMethod.startsWith("COD")) {
                thinkingDiv.classList.add("cod-thinking");
              }
              
              const thinkingLabel = document.createElement("div");
              thinkingLabel.className = "thinking-label";
              thinkingLabel.textContent = msg.reasoningMethod && msg.reasoningMethod.startsWith("COD") ? 
                "Chain of Draft Steps" : "Thinking Steps";
              thinkingDiv.appendChild(thinkingLabel);
              
              // Format thinking steps using the improved formatted steps function
              const thinkingContent = document.createElement("div");
              thinkingContent.innerHTML = formatThinkingSteps(
                msg.thinking, 
                msg.reasoningMethod ? msg.reasoningMethod.toLowerCase() : REASONING_METHOD
              );
              thinkingDiv.appendChild(thinkingContent);
              
              messageContainer.appendChild(thinkingDiv);
            }
            
            // If we have an answer (for CoD, CoT or Standard)
            if (msg.answer) {
              const answerDiv = document.createElement("div");
              answerDiv.className = "final-answer";
              
              const answerLabel = document.createElement("div");
              answerLabel.className = "final-answer-label";
              answerLabel.textContent = "Final Answer";
              answerDiv.appendChild(answerLabel);
              
              const answerContent = document.createElement("div");
              answerContent.innerHTML = transformMessage(msg.answer);
              answerDiv.appendChild(answerContent);
              
              messageContainer.appendChild(answerDiv);
            }
            
            // If we have neither thinking nor answer (fall back to content)
            if (!msg.thinking && !msg.answer) {
              const contentEl = document.createElement("div");
              contentEl.innerHTML = transformMessage(msg.content);
              messageContainer.appendChild(contentEl);
            }
            
            messageDiv.appendChild(messageContainer);
          } else {
            // Standard rendering for user messages or placeholders
            const contentEl = document.createElement("div");
            contentEl.innerHTML = transformMessage(msg.content);
            messageDiv.appendChild(contentEl);
          }
          
          // Add word count badge for bot messages (except placeholders)
          if (msg.sender === "bot" && !msg.isPlaceholder && msg.wordCount !== undefined) {
            const wordCountBadge = document.createElement("div");
            wordCountBadge.className = "word-count-badge";
            
            // Calculate token savings if we have CoD
            let badgeText = `${msg.wordCount} words - ${msg.reasoningMethod || REASONING_METHOD.toUpperCase()}`;
            
            // If this is a CoD message, add token savings estimate
            if (msg.reasoningMethod && msg.reasoningMethod.startsWith("COD") && thread.messages.length > 1) {
              // Find a similar CoT message (if available) to compare token savings
              const cotMessages = thread.messages.filter(m => 
                m.sender === "bot" && 
                m.reasoningMethod && 
                m.reasoningMethod === "COT" && 
                !m.isPlaceholder
              );
              
              if (cotMessages.length > 0) {
                // Calculate average token savings compared to CoT
                const avgCotWords = cotMessages.reduce((sum, m) => sum + m.wordCount, 0) / cotMessages.length;
                const savings = Math.round(100 - ((msg.wordCount / avgCotWords) * 100));
                
                if (savings > 0) {
                  badgeText += ` (${savings}% fewer words)`;
                }
              }
            }
            
            wordCountBadge.textContent = badgeText;
            messageDiv.appendChild(wordCountBadge);
          }

          chatMessagesDiv.appendChild(messageDiv);
        });
        chatMessagesDiv.scrollTop = chatMessagesDiv.scrollHeight;
      }
      addCodeCopyButtons();
    }

    function addMessageToCurrentThread(content, sender, isPlaceholder = false) {
      const thread = threads.find(t => t.id === currentThreadId);
      if (thread) {
        // Process bot messages to separate thinking from answer
        let thinking = null;
        let answer = null;
        
        if (sender === "bot" && !isPlaceholder) {
          const processed = processBotMessage(content, REASONING_METHOD);
          thinking = processed.thinking;
          answer = processed.answer;
        }
        
        thread.messages.push({
          content,
          sender,
          isPlaceholder,
          timestamp: new Date(),
          wordCount: sender === "bot" && !isPlaceholder ? countWords(content) : undefined,
          reasoningMethod: sender === "bot" && !isPlaceholder ? 
            (REASONING_METHOD === "cod" ? `${REASONING_METHOD.toUpperCase()}-${COD_WORD_LIMIT}` : REASONING_METHOD.toUpperCase()) : 
            undefined,
          thinking,
          answer
        });
        renderCurrentThreadMessages();
      }
    }

    /***********************
     * Build Messages Array for Chat Completions
     ***********************/
    function buildMessagesForChat() {
      const thread = threads.find(t => t.id === currentThreadId);
      if (!thread) return [];
      
      const messages = [];
      
      let systemPrompt = "";
      
      // If we have a reasoning method other than standard, add the system prompt
      if (REASONING_METHOD !== "standard") {
        // Use the selected reasoning method prompt
        systemPrompt = PROMPTS[REASONING_METHOD];
        
        // If it's COD, update the word limit
        if (REASONING_METHOD === "cod" && COD_WORD_LIMIT !== 5) {
          systemPrompt = systemPrompt.replace(/\(\d+ words maximum per step\)/, `(${COD_WORD_LIMIT} words maximum per step)`);
        }
        
        console.log(`Using ${REASONING_METHOD.toUpperCase()} prompt ${REASONING_METHOD === "cod" ? "with word limit " + COD_WORD_LIMIT : ""}`);
        
        messages.push({
          role: "system",
          content: systemPrompt
        });
      } else {
        console.log("Using standard reasoning (no special prompt)");
      }
      
      // Add all user and assistant messages
      thread.messages
        .filter(msg => !msg.isPlaceholder)
        .forEach(msg => {
          messages.push({
            role: msg.sender === "user" ? "user" : "assistant",
            content: msg.content
          });
        });
      
      return messages;
    }

    /***********************
     * Message Sending
     ***********************/
    async function sendMessage(message) {
      addMessageToCurrentThread(message, "user");

      if (!MODEL_NAME) {
        const errorMsg = "Error: Please set the Model Name in the Settings.";
        addMessageToCurrentThread(errorMsg, "bot");
        console.error(errorMsg);
        return;
      }

      addMessageToCurrentThread("Bot is typing...", "bot", true);
      const thread = threads.find(t => t.id === currentThreadId);
      const placeholderIndex = thread.messages.length - 1;

      // Build messages array with current settings
      const messagesForApi = buildMessagesForChat();

      // Create payload
      const payload = {
        model: MODEL_NAME,
        max_tokens: MAX_TOKENS,
        top_p: TOP_P,
        top_k: TOP_K,
        presence_penalty: PRESENCE_PENALTY,
        frequency_penalty: FREQUENCY_PENALTY,
        temperature: TEMPERATURE,
        messages: messagesForApi
      };
      
      console.log(`Sending request with ${REASONING_METHOD} reasoning ${REASONING_METHOD === "cod" ? `(word limit: ${COD_WORD_LIMIT})` : ""}`);
      console.log(`Parameters: temp=${TEMPERATURE}, top_p=${TOP_P}, top_k=${TOP_K}`);

      try {
        // Add timestamp to URL to prevent caching
        const timestamp = new Date().getTime();
        const cacheBuster = `?t=${timestamp}`;
        
        const response = await fetch(`${API_PROXY_URL}${cacheBuster}`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify(payload)
        });
        
        if (!response.ok) {
          throw new Error(`HTTP error! Status: ${response.status}`);
        }
        
        const data = await response.json();
        const botReply = data.choices &&
                         data.choices[0] &&
                         data.choices[0].message &&
                         data.choices[0].message.content;
        if (botReply) {
          const trimmedReply = botReply.trim();
          const wordCount = countWords(trimmedReply);
          
          // Create response metadata
          let reasoningInfo = REASONING_METHOD.toUpperCase();
          if (REASONING_METHOD === "cod") {
            reasoningInfo += `-${COD_WORD_LIMIT}`;
          }
          
          // Process bot message to separate thinking and answer parts
          const processed = processBotMessage(trimmedReply, REASONING_METHOD);
          
          thread.messages[placeholderIndex] = {
            content: trimmedReply,
            sender: "bot",
            isPlaceholder: false,
            timestamp: new Date(),
            wordCount: wordCount,
            reasoningMethod: reasoningInfo,
            thinking: processed.thinking,
            answer: processed.answer
          };
        } else {
          thread.messages[placeholderIndex] = {
            content: "No valid response received. Check model name and API key.",
            sender: "bot",
            isPlaceholder: false,
            timestamp: new Date(),
            wordCount: 0,
            reasoningMethod: REASONING_METHOD.toUpperCase(),
            thinking: null,
            answer: null
          };
        }
      } catch (error) {
        console.error("Error communicating with API:", error);
        
        // Provide more detailed error message
        let errorMessage = "Error communicating with API: " + error.message;
        
        // Add suggestions based on error type
        if (error.message.includes("Failed to fetch")) {
          errorMessage += "\n\nPossible solutions:\n1. Make sure your API key is set correctly in Netlify\n2. Check that your model name is valid\n3. Verify your internet connection";
        }
        
        thread.messages[placeholderIndex] = {
          content: errorMessage,
          sender: "bot",
          isPlaceholder: false,
          timestamp: new Date(),
          wordCount: 0,
          reasoningMethod: REASONING_METHOD.toUpperCase(),
          thinking: null,
          answer: null
        };
      }
      renderCurrentThreadMessages();
    }

    /***********************
     * Code Copy Feature
     ***********************/
    function addCodeCopyButtons() {
      const codeBlocks = document.querySelectorAll('pre code');
      codeBlocks.forEach(code => {
        if (code.parentElement.classList.contains('code-block-container')) {
          return;
        }
        const pre = code.parentElement;
        const container = document.createElement('div');
        container.className = 'code-block-container';
        pre.parentNode.insertBefore(container, pre);
        container.appendChild(pre);

        const copyBtn = document.createElement('button');
        copyBtn.className = 'copy-btn';
        copyBtn.textContent = 'Copy';
        copyBtn.addEventListener('click', () => {
          navigator.clipboard.writeText(code.innerText);
          copyBtn.textContent = 'Copied!';
          setTimeout(() => {
            copyBtn.textContent = 'Copy';
          }, 1500);
        });
        container.appendChild(copyBtn);
      });
    }

    /***********************
     * Notification System
     ***********************/
    function showNotification(message, duration = 3000) {
      const notification = document.getElementById("statusNotification");
      notification.textContent = message;
      notification.classList.add("show");
      
      setTimeout(() => {
        notification.classList.remove("show");
      }, duration);
    }

    /***********************
     * Feedback Form
     ***********************/
    function initFeedbackForm() {
      // Get references to elements
      const openBtn = document.getElementById('openFeedbackBtn');
      const modal = document.getElementById('feedbackModal');
      const closeBtn = document.getElementById('closeFeedbackModal');
      const modelInput = document.getElementById('feedbackModel');
      const reasoningInput = document.getElementById('feedbackReasoning');
      
      // Set up event listeners
      if (openBtn) {
        openBtn.addEventListener('click', () => {
          // Update hidden fields with current model info
          if (modelInput) modelInput.value = MODEL_NAME_DISPLAY || 'Not set';
          if (reasoningInput) {
            let reasoningMethod = REASONING_METHOD.toUpperCase();
            if (REASONING_METHOD === 'cod') {
              reasoningMethod += `-${COD_WORD_LIMIT}`;
            }
            reasoningInput.value = reasoningMethod;
          }
          
          // Show the modal
          if (modal) modal.style.display = 'block';
        });
      }
      
      if (closeBtn) {
        closeBtn.addEventListener('click', () => {
          if (modal) modal.style.display = 'none';
        });
      }
      
      // Close modal when clicking outside
      window.addEventListener('click', (event) => {
        if (event.target === modal) {
          modal.style.display = 'none';
        }
      });
      
      // Show success message after form submission
      const form = document.querySelector('form[name="feedback"]');
      if (form) {
        form.addEventListener('submit', () => {
          setTimeout(() => {
            showNotification('Thank you for your feedback!');
            if (modal) modal.style.display = 'none';
          }, 500);
        });
      }
    }

    /***********************
     * Settings Management
     ***********************/
    
    // Tab handling
    function setupTabNavigation() {
      try {
        console.log("Setting up tab navigation");
        
        // Get all tab buttons and tab contents
        const tabButtons = document.querySelectorAll('.tab-btn');
        const tabContents = document.querySelectorAll('.tab-content');
        
        if (tabButtons.length === 0) {
          console.warn("No tab buttons found");
        }
        
        // Add click event listeners to tab buttons
        tabButtons.forEach(button => {
          button.addEventListener('click', () => {
            try {
              // Remove active class from all buttons and contents
              tabButtons.forEach(btn => btn.classList.remove('active'));
              tabContents.forEach(content => content.classList.remove('active'));
              
              // Add active class to clicked button
              button.classList.add('active');
              
              // Show corresponding tab content
              const tabId = button.getAttribute('data-tab');
              const tabContent = document.getElementById(tabId);
              if (tabContent) {
                tabContent.classList.add('active');
              } else {
                console.warn(`Tab content with id "${tabId}" not found`);
              }
            } catch (err) {
              console.error("Error handling tab click:", err);
            }
          });
        });
      } catch (err) {
        console.error("Error in setupTabNavigation:", err);
      }
    }
    
    // Custom model handling
    function setupModelInput() {
      const modelInput = document.getElementById('modelName');
      const setModelBtn = document.getElementById('setModelBtn');
      
      setModelBtn.addEventListener('click', () => {
        const modelName = modelInput.value.trim();
        if (modelName) {
          MODEL_NAME = modelName;
          MODEL_NAME_DISPLAY = getModelDisplayName(modelName);
          updateCurrentModelDisplay();
          showNotification('Model set: ' + MODEL_NAME_DISPLAY);
        } else {
          showNotification('Please enter a valid model name');
        }
      });
    }
    
    // Improved Chain of Draft word limit options UI
    function updateCoDOptionsUI() {
      const codOptions = document.getElementById('codOptions');
      if (!codOptions) return;
      
      codOptions.innerHTML = `
        <div class="option-label">Word limit per step:</div>
        <div class="cod-word-limit-options">
          <div class="cod-word-limit-option ${COD_WORD_LIMIT === 5 ? 'selected' : ''}" data-value="5">
            <span class="cod-word-limit-value">5 words</span>
            <span class="cod-word-limit-desc">Original paper recommendation</span>
          </div>
          <div class="cod-word-limit-option ${COD_WORD_LIMIT === 10 ? 'selected' : ''}" data-value="10">
            <span class="cod-word-limit-value">10 words</span>
            <span class="cod-word-limit-desc">Balanced brevity and clarity</span>
          </div>
          <div class="cod-word-limit-option ${COD_WORD_LIMIT === 15 ? 'selected' : ''}" data-value="15">
            <span class="cod-word-limit-value">15 words</span>
            <span class="cod-word-limit-desc">More descriptive steps</span>
          </div>
        </div>
        
        <div class="cod-examples">
          <div class="cod-examples-header">Chain of Draft Example</div>
          <div class="cod-example-item">
            <div class="cod-example-question">Q: If a fabric store received 45 yards of cotton and used 2/9 of it, how many yards remain?</div>
            <div class="cod-example-answer">A: Total: 45 yards. Used: 2/9 × 45 = 10 yards. Remaining: 45 - 10 = 35 yards. #### 35 yards</div>
          </div>
        </div>
      `;
      
      // Add event listeners to the word limit options
      const wordLimitOptions = document.querySelectorAll('.cod-word-limit-option');
      wordLimitOptions.forEach(option => {
        option.addEventListener('click', () => {
          // Update selected state
          wordLimitOptions.forEach(opt => opt.classList.remove('selected'));
          option.classList.add('selected');
          
          // Update word limit value
          COD_WORD_LIMIT = parseInt(option.getAttribute('data-value'));
          
          // Update the prompt
          updateCoDPrompt();
          
          // Update display
          updateCurrentModelDisplay();
        });
      });
    }
    
    // Improved function to update the CoD prompt when word limit changes
    function updateCoDPrompt() {
      // Update the prompt to reflect new word limit
      const basePrompt = `Think step by step, but produce only minimal notes for each step (${COD_WORD_LIMIT} words maximum per step). Use mathematical notation where possible. Keep only essential information needed to solve the problem. Focus on key calculations and intermediate results without narrative explanation.
  
Separate your steps with periods. Write your final answer after the #### separator.`;
      
      // Keep the examples part of the prompt
      const examplesStart = PROMPTS.cod.indexOf('Examples:');
      if (examplesStart !== -1) {
        PROMPTS.cod = basePrompt + '\n\n' + PROMPTS.cod.substring(examplesStart);
      } else {
        PROMPTS.cod = basePrompt;
      }
      
      console.log(`Updated CoD prompt with word limit: ${COD_WORD_LIMIT}`);
    }
    
    // Setup COD options display
    function setupCODOptions() {
      const reasoningRadios = document.getElementsByName('reasoningMethod');
      const codOptions = document.getElementById('codOptions');
      
      // Initial state
      if (REASONING_METHOD === 'cod') {
        codOptions.style.display = 'block';
        updateCoDOptionsUI();
      } else {
        codOptions.style.display = 'none';
      }
      
      // Update when reasoning method changes
      reasoningRadios.forEach(radio => {
        radio.addEventListener('change', () => {
          if (radio.value === 'cod' && radio.checked) {
            codOptions.style.display = 'block';
            updateCoDOptionsUI();
          } else {
            codOptions.style.display = 'none';
          }
        });
      });
    }
    
    // Settings slider handling
    function setupSliders() {
      // Connect all sliders to their value displays
      document.querySelectorAll('input[type="range"]').forEach(slider => {
        const valueDisplay = document.getElementById(`${slider.id}Value`);
        if (valueDisplay) {
          slider.addEventListener('input', () => {
            valueDisplay.textContent = slider.value;
          });
        }
      });
    }
    
    function openSettingsModal() {
      try {
        console.log("Opening settings modal");
        
        // Initialize settings UI
        const modelNameInput = document.getElementById("modelName");
        if (modelNameInput) modelNameInput.value = MODEL_NAME;
        
        // Set reasoning method radio buttons
        const reasoningRadio = document.getElementById(`${REASONING_METHOD}Reasoning`);
        if (reasoningRadio) reasoningRadio.checked = true;
        
        // Set parameter sliders
        setSliderAndValue("temp", TEMPERATURE);
        setSliderAndValue("topP", TOP_P);
        setSliderAndValue("topK", TOP_K);
        setSliderAndValue("maxTokens", MAX_TOKENS);
        setSliderAndValue("presencePenalty", PRESENCE_PENALTY);
        setSliderAndValue("frequencyPenalty", FREQUENCY_PENALTY);
        
        // Show modal
        const modal = document.getElementById("settingsModal");
        if (modal) modal.style.display = "block";
        
        console.log("Settings modal opened successfully");
      } catch (err) {
        console.error("Error in openSettingsModal:", err);
      }
    }
    
    function setSliderAndValue(id, value) {
      const slider = document.getElementById(id);
      const valueDisplay = document.getElementById(`${id}Value`);
      
      if (slider) slider.value = value;
      if (valueDisplay) valueDisplay.textContent = value;
    }

    function closeSettingsModal() {
      document.getElementById("settingsModal").style.display = "none";
    }

    function saveSettings() {
      try {
        console.log("Saving settings...");
        
        // Save previous settings for comparison
        const prevMethod = REASONING_METHOD;
        const prevWordLimit = COD_WORD_LIMIT;
        
        // Save model name
        const modelNameEl = document.getElementById("modelName");
        if (modelNameEl) {
          MODEL_NAME = modelNameEl.value.trim();
          MODEL_NAME_DISPLAY = getModelDisplayName(MODEL_NAME);
        }
        
        // Save reasoning method
        const reasoningRadios = document.getElementsByName("reasoningMethod");
        for (const radio of reasoningRadios) {
          if (radio.checked) {
            REASONING_METHOD = radio.value;
            break;
          }
        }
        
        // Save COD word limit if applicable
        if (REASONING_METHOD === "cod") {
          // Get the selected CoD word limit option
          const selectedOption = document.querySelector('.cod-word-limit-option.selected');
          if (selectedOption) {
            COD_WORD_LIMIT = parseInt(selectedOption.getAttribute('data-value'));
          }
        }
        
        // Save generation parameters safely
        const getNumericValue = (id, defaultVal, parseFunc) => {
          const el = document.getElementById(id);
          return el ? parseFunc(el.value) : defaultVal;
        };
        
        TEMPERATURE = getNumericValue("temp", 0.5, parseFloat);
        TOP_P = getNumericValue("topP", 0.9, parseFloat);
        TOP_K = getNumericValue("topK", 55, parseInt);
        MAX_TOKENS = getNumericValue("maxTokens", 1112, parseInt);
        PRESENCE_PENALTY = getNumericValue("presencePenalty", 0, parseFloat);
        FREQUENCY_PENALTY = getNumericValue("frequencyPenalty", 0.4, parseFloat);
        
        // Update model display
        updateCurrentModelDisplay();
        
        // Save settings to localStorage
        try {
          localStorage.setItem("modelName", MODEL_NAME);
          localStorage.setItem("reasoningMethod", REASONING_METHOD);
          localStorage.setItem("codWordLimit", COD_WORD_LIMIT.toString());
          localStorage.setItem("temperature", TEMPERATURE.toString());
          localStorage.setItem("topP", TOP_P.toString());
          localStorage.setItem("topK", TOP_K.toString());
          localStorage.setItem("maxTokens", MAX_TOKENS.toString());
          localStorage.setItem("presencePenalty", PRESENCE_PENALTY.toString());
          localStorage.setItem("frequencyPenalty", FREQUENCY_PENALTY.toString());
          
          // Save custom prompts
          localStorage.setItem("customPrompts", JSON.stringify(PROMPTS));
          console.log("Settings saved to localStorage");
        } catch (storageErr) {
          console.error("Error saving to localStorage:", storageErr);
        }
        
        closeSettingsModal();
        
        // Check if reasoning method or COD word limit changed and notify user
        if (prevMethod !== REASONING_METHOD || 
            (REASONING_METHOD === "cod" && prevMethod === "cod" && prevWordLimit !== COD_WORD_LIMIT)) {
          showNotification("Settings saved - reasoning method changed. Next message will use new settings.");
        } else {
          showNotification("Settings saved");
        }
      } catch (err) {
        console.error("Error in saveSettings:", err);
        showNotification("Error saving settings");
      }
    }

    /***********************
     * Event Listeners
     ***********************/
    function initEventListeners() {
      try {
        console.log("Initializing event listeners");
        
        // Helper function to safely add event listeners
        const addListener = (id, event, handler) => {
          const element = document.getElementById(id);
          if (element) {
            element.addEventListener(event, handler);
          } else {
            console.warn(`Element with id "${id}" not found for event listener`);
          }
        };
        
        // Settings buttons
        addListener("openSettings", "click", openSettingsModal);
        addListener("closeSettings", "click", closeSettingsModal);
        addListener("closeModalX", "click", closeSettingsModal);
        addListener("saveSettings", "click", saveSettings);
        
        // Thread management
        addListener("newThreadBtn", "click", createNewThread);
        addListener("deleteThreadBtn", "click", deleteCurrentThread);
        addListener("downloadTxtBtn", "click", downloadCurrentThreadAsTxt);
        addListener("downloadPdfBtn", "click", downloadCurrentThreadAsPdf);
        
        // Message sending
        addListener("sendBtn", "click", () => {
          const userInput = document.getElementById("userInput");
          if (userInput) {
            const message = userInput.value.trim();
            if (message) {
              sendMessage(message);
              userInput.value = "";
            }
          }
        });
        
        const userInput = document.getElementById("userInput");
        if (userInput) {
          userInput.addEventListener("keydown", (event) => {
            if (event.key === "Enter" && !event.shiftKey) {
              event.preventDefault();
              const sendBtn = document.getElementById("sendBtn");
              if (sendBtn) sendBtn.click();
            }
          });
        }
        
        // Close modal when clicking outside
        window.addEventListener("click", (event) => {
          const modal = document.getElementById("settingsModal");
          if (modal && event.target === modal) {
            closeSettingsModal();
          }
        });
        
        // Set up settings UI functionality
        setTimeout(() => {
          try {
            setupTabNavigation();
            setupModelInput();
            setupCODOptions();
            setupSliders();
            console.log("UI functionality setup complete");
          } catch (err) {
            console.error("Error setting up UI functionality:", err);
          }
        }, 100);
      } catch (err) {
        console.error("Error initializing event listeners:", err);
      }
    }

    /***********************
     * Initialization
     ***********************/
    function loadPersistedSettings() {
      try {
        MODEL_NAME = localStorage.getItem("modelName") || "";
        MODEL_NAME_DISPLAY = getModelDisplayName(MODEL_NAME);
        
        REASONING_METHOD = localStorage.getItem("reasoningMethod") || "cod";
        
        const codWordLimit = localStorage.getItem("codWordLimit");
        if (codWordLimit) COD_WORD_LIMIT = parseInt(codWordLimit);
        
        // Load custom prompts if available
        const storedPrompts = localStorage.getItem("customPrompts");
        if (storedPrompts) {
          const parsedPrompts = JSON.parse(storedPrompts);
          // Merge with default prompts to ensure all properties exist
          PROMPTS = { ...PROMPTS, ...parsedPrompts };
        }
        
        const temp = localStorage.getItem("temperature");
        if (temp) TEMPERATURE = parseFloat(temp);
        
        const topP = localStorage.getItem("topP");
        if (topP) TOP_P = parseFloat(topP);
        
        const topK = localStorage.getItem("topK");
        if (topK) TOP_K = parseInt(topK);
        
        const maxTokens = localStorage.getItem("maxTokens");
        if (maxTokens) MAX_TOKENS = parseInt(maxTokens);
        
        const presencePenalty = localStorage.getItem("presencePenalty");
        if (presencePenalty) PRESENCE_PENALTY = parseFloat(presencePenalty);
        
        const frequencyPenalty = localStorage.getItem("frequencyPenalty");
        if (frequencyPenalty) FREQUENCY_PENALTY = parseFloat(frequencyPenalty);
      } catch (err) {
        console.error("Error loading settings:", err);
      }
    }

    function init() {
      console.log("Initializing app...");
      
      try {
        loadPersistedSettings();
        console.log("Settings loaded");
        
        // Update CoD prompt with the correct word limit
        updateCoDPrompt();
        console.log("CoD prompt updated");
        
        createNewThread();
        console.log("New thread created");
        
        initEventListeners();
        console.log("Event listeners initialized");
        
        updateCurrentModelDisplay();
        console.log("Model display updated");
        
        // Initialize feedback form
        initFeedbackForm();
        console.log("Feedback form initialized");
        
        // Helper function to create a button that resets the thread
        function createClearThreadButton() {
          const clearThreadBtn = document.createElement("button");
          clearThreadBtn.id = "clearThreadBtn";
          clearThreadBtn.textContent = "Clear Thread";
          clearThreadBtn.style.marginTop = "0.5rem";
          clearThreadBtn.style.backgroundColor = "#553333";
          clearThreadBtn.addEventListener("click", () => {
            if (confirm("Clear all messages in this thread?")) {
              const thread = threads.find(t => t.id === currentThreadId);
              if (thread) {
                thread.messages = [];
                renderCurrentThreadMessages();
                showNotification("Thread cleared");
              }
            }
          });
          return clearThreadBtn;
        }
        
        // Add clear thread button to the sidebar
        const sidebar = document.querySelector(".sidebar");
        if (sidebar) {
          sidebar.appendChild(createClearThreadButton());
        }
        
        // If we don't have a model name, open settings modal
        if (!MODEL_NAME) {
          console.log("No model name found, opening settings");
          setTimeout(() => {
            try {
              openSettingsModal();
              console.log("Settings modal opened");
            } catch (err) {
              console.error("Error opening settings modal:", err);
            }
          }, 1000);
        }
      } catch (err) {
        console.error("Initialization error:", err);
      }
    }

    // Initialize the application
    document.addEventListener("DOMContentLoaded", init);
    
    // Backup initialization - in case the DOMContentLoaded event already fired
    if (document.readyState === "complete" || document.readyState === "interactive") {
      setTimeout(init, 1);
    }
  </script>
  <form name="feedback" netlify netlify-honeypot="bot-field" hidden>
    <input type="hidden" name="form-name" value="feedback">
    <input type="hidden" name="model">
    <input type="hidden" name="reasoning_method">
    <select name="feedback_type"></select>
    <input type="radio" name="rating" value="1">
    <input type="radio" name="rating" value="2">
    <input type="radio" name="rating" value="3">
    <input type="radio" name="rating" value="4">
    <input type="radio" name="rating" value="5">
    <textarea name="comments"></textarea>
  </form>
</body>
</html>
